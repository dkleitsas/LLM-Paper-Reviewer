Section,Section Appearance Order,Paragraph
ABSTRACT,0.0,ABSTRACT
ABSTRACT,0.002932551319648094,"Sketching is a dimensionality reduction technique where one compresses a matrix
by linear combinations that are chosen at random. A line of work has shown how
to sketch the Hessian to speed up each iteration in a second order method, but such
sketches usually depend only on the matrix at hand, and in a number of cases are
even oblivious to the input matrix. One could instead hope to learn a distribution on
sketching matrices that is optimized for the speciÔ¨Åc distribution of input matrices.
We show how to design learned sketches for the Hessian in the context of second
order methods. We prove that a smaller sketching dimension of the column space
of a tall matrix is possible, given an oracle that can predict the indices of the rows of
large leverage score. We design such an oracle for various datasets, and this leads to
a faster convergence of the well-studied iterative Hessian sketch procedure, which
applies to a wide range of problems in convex optimization. We show empirically
that learned sketches, compared with their ‚Äúnon-learned‚Äù counterparts, do improve
the approximation accuracy for important problems, including LASSO and matrix
estimation with nuclear norm constraints."
INTRODUCTION,0.005865102639296188,"1
INTRODUCTION"
INTRODUCTION,0.008797653958944282,"Large-scale optimization problems are abundant and solving them efÔ¨Åciently requires powerful tools
to make the computation practical. This is especially true of second order methods which often are
less practical than Ô¨Årst order ones. Although second order methods may have many fewer iterations,
each iteration could involve inverting a large Hessian, which is cubic time; in contrast, Ô¨Årst order
methods such as stochastic gradient descent are linear time per iteration."
INTRODUCTION,0.011730205278592375,"In order to make second order methods faster in each iteration, a large body of work has looked at
dimensionality reduction techniques, such as sampling, sketching, or approximating the Hessian by a
low rank matrix. See, for example, (Gower et al., 2016; Xu et al., 2016; Pilanci & Wainwright, 2016;
2017; Doikov & Richt√°rik, 2018; Gower et al., 2018; Roosta-Khorasani & Mahoney, 2019; Gower
et al., 2019; Kylasa et al., 2019; Xu et al., 2020; Li et al., 2020). Our focus is on sketching techniques,
which often consist of multiplying the Hessian by a random matrix chosen independently of the
Hessian. Sketching has a long history in theoretical computer science (see, e.g., (Woodruff, 2014) for
a survey), and we describe such methods more below. A special case of sketching is sampling, which
in practice is often uniform sampling, and hence oblivious to properties of the actual matrix. Other
times the sampling is non-uniform, and based on squared norms of submatrices of the Hessian or on
the leverage scores of the Hessian."
INTRODUCTION,0.01466275659824047,"Our focus is on sketching techniques, and in particular, we consider the framework of (Pilanci &
Wainwright, 2016; 2017) which introduces the iterative Hessian sketch and the Newton sketch, as
well as the high accuracy reÔ¨Ånement given in (van den Brand et al., 2020). If one were to run
Newton‚Äôs method to Ô¨Ånd a point where the gradient is zero, in each iteration one needs to solve an
equation involving the current Hessian and gradient to Ô¨Ånd the update direction. When the Hessian
can be decomposed as A‚ä§A for an n √ó d matrix A with n ‚â´d, then sketching is particularly
suitable. The iterative Hessian sketch was proposed in Pilanci & Wainwright (2016), where A is
replaced with S ¬∑ A, for a random matrix S which could be i.i.d. Gaussian or drawn from a more
structured family of random matrices such as the Subsampled Randomized Hadamard Transforms
or COUNT-SKETCH matrices; the latter was done in (Cormode & Dickens, 2019). The Newton
sketch was proposed by Pilanci & Wainwright (2017), which extended sketching methods beyond
constrained least-squares problems to any twice differentiable function subject to a closed convex
constraint set. Using this sketch inside of interior point updates has led to much faster algorithms"
INTRODUCTION,0.017595307917888565,Under review as a conference paper at ICLR 2022
INTRODUCTION,0.020527859237536656,"for an extensive body of convex optimization problems (Pilanci & Wainwright, 2017). By instead
using sketching as a preconditioner, an application of the work of (van den Brand et al., 2020) (see
Appendix E) was able to improve the dependence on the accuracy parameter œµ to logarithmic."
INTRODUCTION,0.02346041055718475,"In general, the idea behind sketching is the following. One chooses a random matrix S, drawn from a
certain family of random matrices, and computes SA. If A is tall-and-thin, then S is short-and-fat, and
thus SA is a small, roughly square matrix. Moreover, SA preserves important properties of A. One
typically desired property is that S is a subspace embedding, meaning that ‚à•SAx‚à•2 = (1 ¬± œµ)‚à•Ax‚à•2
for all x simultaneously. An observation exploited in Cormode & Dickens (2019), building off of
the COUNT-SKETCH random matrices S introduced in randomized linear algebra in Clarkson &
Woodruff (2017), is that if S contains a single non-zero entry per column, then SA can be computed
in O(nnz(A)) time, where nnz(A) denotes the number of nonzeros in A. This is also referred to as
input-sparsity running time."
INTRODUCTION,0.026392961876832845,"Each iteration of a second order method often involves solving an equation of the form A‚ä§Ax = A‚ä§b,
where A‚ä§A is the Hessian and b is the gradient. For a number of problems, one has access to a
matrix A ‚ààRn√ód with n ‚â´d, which is also an assumption made in Pilanci & Wainwright (2017).
Therefore, the solution x is the minimizer to a constrained least squares regression problem:"
INTRODUCTION,0.02932551319648094,"min
x‚ààC
1
2 ‚à•Ax ‚àíb‚à•2
2 ,
(1)"
INTRODUCTION,0.03225806451612903,"where C is a convex constraint set in Rd. For the unconstrained case (C = Rd), various classical
sketches that attain the subspace embedding property can provably yield high-accuracy approximate
solutions (see, e.g., (Sarlos, 2006; Nelson & Nguy√™n, 2013; Cohen, 2016; Clarkson & Woodruff,
2017)); for the general constrained case, the Iterative Hessian Sketch (IHS) was proposed by Pilanci &
Wainwright (2016) as an effective approach and Cormode & Dickens (2019) employed sparse sketches
to achieve input-sparsity running time for IHS. All sketches used in these results are data-oblivious
random sketches."
INTRODUCTION,0.03519061583577713,"Learned Sketching.
In the last few years, an exciting new notion of learned sketching has emerged.
Here the idea is that one often sees independent samples of matrices A from a distribution D, and
can train a model to learn the entries in a sketching matrix S on these samples. When given a future
sample B, also drawn from D, the learned sketching matrix S will be such that S ¬∑ B is a much
more accurate compression of B than if S had the same number of rows and were instead drawn
without knowledge of D. Moreover, the learned sketch S is often sparse, therefore allowing S ¬∑ B to
be applied very quickly. For large datasets B this is particularly important, and distinguishes this
approach from other transfer learning approaches, e.g., (Andrychowicz et al., 2016), which can be
considerably slower in this context."
INTRODUCTION,0.03812316715542522,"Learned sketches were Ô¨Årst used in the data stream context for Ô¨Ånding frequent items (Hsu et al.,
2019) and have subsequently been applied to a number of other problems on large data. For example,
Indyk et al. (2019) showed that learned sketches yield signiÔ¨Åcantly smaller errors for low rank
approximation. Dong et al. (2020) made signiÔ¨Åcant improvements to nearest neighbor search using
learned sketches. More recently, Liu et al. (2020) extended learned sketches to several problems in
numerical linear algebra, including least-squares regression, as well as k-means clustering."
INTRODUCTION,0.04105571847507331,"Despite the number of problems that learned sketches have been applied to, they have not been
applied to convex optimization in general. Given that such methods often require solving a large
overdetermined least squares problem in each iteration, it is hopeful that one can improve each
iteration using learned sketches. However, a number of natural questions arise: (1) how should we
learn the sketch? (2) should we apply the same learned sketch in each iteration, or learn it in the next
iteration by training on a data set involving previously learned sketches from prior iterations?"
INTRODUCTION,0.04398826979472141,"Our Contributions.
In this work we answer the above questions and develop the Ô¨Årst framework
of learned sketching that applies to a wide number of problems in convex optimization. Namely, we
apply learned sketches to constrained least-squares problems, including LASSO and matrix regression
with nuclear norm constraints. We show empirically that learned sketches demonstrate superior
accuracy over classical oblivious random sketches for each of these problems. All of our learned
sketches S are extremely sparse, meaning that they contain a single non-zero entry per column and
that they can be applied in input-sparsity time. For such sketches, there are two things to learn: the
position of the non-zero entry in each column and the value of the non-zero entry."
INTRODUCTION,0.0469208211143695,Under review as a conference paper at ICLR 2022
INTRODUCTION,0.04985337243401759,"Following the previous work of Indyk et al. (2019), we choose the position of the nonzero entry in
each column to be uniformly random, while the value of the nonzero entry is learned (the value is
no longer limited to ‚àí1 and 1). Here we consider a new learning objective, that is, we optimize the
subspace embedding property of the sketching matrix instead of optimizing the error in the objective
function of the optimization problem we are trying to solve. This demonstrates a signiÔ¨Åcant advantage
over non-learned sketches, and has a fast training time. Our experiments show that the convergence
rate is reduced by 44% over the nonlearned COUNT-SKETCH (a classical extremely sparse sketch)
for the LASSO problem on a real-world dataset. Recall that a smaller convergence rate means a faster
convergence."
INTRODUCTION,0.05278592375366569,"We prove theoretically that S can take fewer rows, with optimized positions of nonzero entries,
when the input matrix A has a small number of rows of heavy leverage score. More speciÔ¨Åcally,
COUNT-SKETCH takes O(d2/(Œ¥œµ2)) rows with failure probability Œ¥, while our S requires only
O((d polylog(1/œµ) + log(1/Œ¥))/œµ2) rows if A has at most d polylog(1/œµ)/œµ2 rows of leverage score
at least œµ/d. This is a quadratic improvement in d and an exponential improvement in Œ¥. Applying S
to A runs in input-sparsity time and the resulting SA may remain sparse if A is sparse. In practice, it
is not necessary to calculate the leverage scores. Instead, we show in our experiments that the indices
of the rows of heavy leverage score can be learned and the induced S achieves a comparable accuracy
for the abovementioned LASSO problem to classical dense sketches such as Gaussian matrices."
INTRODUCTION,0.05571847507331378,"Combining both aspects, the value of the nonzero entry and the indices of the rows of heavy leverage
score, we obtain even better learned sketches. For the same LASSO problem, we show empirically
that such learned sketches reduce the convergence rate by a larger 79.9% to 84.6% over non-learned
sketches. Therefore, the learned sketches attain a smaller error within the same number of iterations,
and in fact, within the same limit on the maximum runtime, since our sketches are extremely sparse."
INTRODUCTION,0.05865102639296188,"We also study the general framework of convex optimization in van den Brand et al. (2020), and show
that also for sketching-based preconditioning, learned sketches demonstrate considerable advantages.
More precisely, by using a learned sketch with the same number of rows as an oblivious sketch, we
are able to obtain a much better preconditioner with the same overall running time."
PRELIMINARIES,0.06158357771260997,"2
PRELIMINARIES"
PRELIMINARIES,0.06451612903225806,"Algorithm 1 LEARN-SKETCH: Gradient descent
algorithm for learning the sketch values"
PRELIMINARIES,0.06744868035190615,"Require: Atrain = {Ai}N
i=1 (Ai ‚ààRn√ód), learn-
ing rate Œ±
1: Randomly initialize p, v
for a
COUNT-
SKETCH-type sketch as described in the text
2: for t = 0 to step do
3:
Form S using p, v
4:
Sample batch Abatch from Atrain
5:
v ‚Üêv ‚àíŒ± ‚àÇL(S,Abatch) ‚àÇv"
PRELIMINARIES,0.07038123167155426,"Notation. We denote by Sn‚àí1 the unit sphere
in the n-dimensional Euclidean space Rn. For
a matrix A ‚ààRm√ón we denote by ‚à•A‚à•op its
operator norm, which is deÔ¨Åned as ‚à•A‚à•op =
supx‚ààSn‚àí1 ‚à•Ax‚à•2. We also denote by œÉmax(A)
and œÉmin(A) the largest and smallest singular
values of A, respectively, and by colsp(A) the
column space of A. The condition number of A is deÔ¨Åned to be Œ∫(A) = œÉmax(A)/œÉmin(A)."
PRELIMINARIES,0.07331378299120235,"Leverage Scores. We only consider matrices of full column rank1. Suppose that A ‚ààRm√ón (m ‚â•n)
has full column rank. It has m leverage scores, denoted by œÑ1(A), . . . , œÑm(A), which are deÔ¨Åned
as œÑi(A) = ‚à•e‚ä§
i A(A‚ä§A)‚àí1A‚ä§‚à•2
2, where {e1, . . . , em} is the canonical basis of Rm. Equivalently,
letting A = UŒ£V ‚ä§be the singular value decomposition of A, where U ‚ààRm√ón, Œ£, V ‚ààRn√ón, we
can also write œÑi(A) = ‚à•e‚ä§
i UU ‚ä§‚à•2
2 = ‚à•e‚ä§
i U‚à•2
2, which is the squared ‚Ñì2 norm of the i-th row of U."
PRELIMINARIES,0.07624633431085044,"Classical Sketches. Below we review several classical sketches that have been used for solving
optimization problems."
PRELIMINARIES,0.07917888563049853,"‚Ä¢ Gaussian sketch: S =
1
‚àömG, where G ‚ààRm√ón with i.i.d. N(0, 1) entries."
PRELIMINARIES,0.08211143695014662,"‚Ä¢ COUNT-SKETCH: Each column of S has only a single non-zero entry. The position of the
non-zero entry is chosen uniformly over the m entries in the column and the value of the entry
is either +1 or ‚àí1, each with probability 1/2. Further, the columns are chosen independently.
‚Ä¢ Sparse Johnson-Lindenstrauss Transform (SJLT): S is the vertical concatenation of s independent
COUNT-SKETCH matrices, each of dimension m/s √ó n."
PRELIMINARIES,0.08504398826979472,"1This can be assumed w.l.o.g. by adding artbirarily small random noise to the input, or one can Ô¨Årst quickly
use sketching to Ô¨Ånd a subset of columns of maximum rank, and replace the inut with that subset of columns."
PRELIMINARIES,0.08797653958944282,Under review as a conference paper at ICLR 2022
PRELIMINARIES,0.09090909090909091,"COUNT-SKETCH-type Sketch.
A COUNT-SKETCH-type sketch is characterized by a tuple
(m, n, p, v), where m, n are positive integers and p, v are n-dimensional real vectors, deÔ¨Åned as
follows. The sketching matrix S has dimensions m √ó n and Spi,i = vi for all 1 ‚â§i ‚â§n, while
all the other entries of S are 0. When m and n are clear from context, we may characterize such a
sketching matrix by (p, v) only."
PRELIMINARIES,0.093841642228739,"Subspace Embeddings. For a matrix A ‚ààRn√ód, we say a matrix S ‚ààRm√ón is a (1 ¬± œµ)-subspace
embedding for the column span of A if (1 ‚àíœµ) ‚à•Ax‚à•2 ‚â§‚à•SAx‚à•2 ‚â§(1 + œµ) ‚à•Ax‚à•2 for all x ‚ààRd.
The classical sketches above, with appropriate parameters, are all subspace embedding matrices with
probability at least 1 ‚àíŒ¥; our focus is on COUNT-SKETCH which can be applied in input sparsity
running time. We summarize the parameters needed for a subspace embedding below:"
PRELIMINARIES,0.0967741935483871,"‚Ä¢ Gaussian sketch: m = O((d + log(1/Œ¥))/œµ2). It is a dense matrix and computing SA costs
O(m ¬∑ nnz(A)) = O(nnz(A)(d + log(1/Œ¥))/œµ2) time.
‚Ä¢ COUNT-SKETCH: m = O(d2/(Œ¥œµ2)) (Clarkson & Woodruff, 2017). Though the number of
rows is quadratic in d/œµ, the matrix S is sparse and computing SA takes only O(nnz(A)) time.
‚Ä¢ SJLT: m = O(d log( d"
PRELIMINARIES,0.09970674486803519,Œ¥ )/œµ2) and has s = O(log( d
PRELIMINARIES,0.10263929618768329,"Œ¥ )/œµ) non-zeros per column (Nelson & Nguy√™n,
2013; Cohen, 2016). Computing SA takes O(s nnz(A)) = O(nnz(A) log( d"
PRELIMINARIES,0.10557184750733138,Œ¥ )/œµ) time.
PRELIMINARIES,0.10850439882697947,"Iterative Hessian Sketch. The Iterative Hessian Sketching (IHS) method (Pilanci & Wainwright,
2016) solves the constrained least-squares problem (1) by iteratively performing the update"
PRELIMINARIES,0.11143695014662756,"xt+1 = arg min
x‚ààC 1"
PRELIMINARIES,0.11436950146627566,"2 ‚à•St+1A(x ‚àíxt)‚à•2
2 ‚àí‚ü®A‚ä§(b ‚àíAxt), x ‚àíxt‚ü©

,
(2)"
PRELIMINARIES,0.11730205278592376,"where St+1 is a sketching matrix. It is not difÔ¨Åcult to see that for the unsketched version (St+1 is
the identity matrix) of the minimization above, the optimal solution xt+1 coincides with the optimal
solution to the constrained least squares problem (1). The IHS approximates the Hessian A‚ä§A by a
sketched version (St+1A)‚ä§(St+1A) to improve runtime, as St+1A typically has very few rows."
PRELIMINARIES,0.12023460410557185,"Unconstrained Convex Optimization. Consider an unconstrained convex optimization problem
minx f(x), where f is smooth and strongly convex, and its Hessian ‚àá2f is Lipschitz continuous.
This problem can be solved by Newton‚Äôs method, which iteratively performs the update"
PRELIMINARIES,0.12316715542521994,"xt+1 = xt ‚àíarg min
z"
PRELIMINARIES,0.12609970674486803,"(‚àá2f(xt)1/2)‚ä§(‚àá2f(xt)1/2)z ‚àí‚àáf(xt)

2 ,
(3)"
PRELIMINARIES,0.12903225806451613,"provided it is given a good initial point x0. In each step, it requires solving a regression problem of
the form minz
A‚ä§Az ‚àíy

2, which, with access to A, can be solved with a fast regression solver
in (van den Brand et al., 2020). The regression solver Ô¨Årst computes a preconditioner R via a QR
decomposition such that SAR has orthonormal columns, where S is a sketching matrix, then solves
bz = arg minz‚Ä≤
(AR)‚ä§(AR)z‚Ä≤ ‚àíy

2 by gradient descent and returns Rbz in the end. Here, the point
of sketching is that the QR decomposition of SA can be computed much more efÔ¨Åciently than the
QR decomposition of A, since S has only a small number of rows."
PRELIMINARIES,0.13196480938416422,"Learning a Sketch. We use the same learning algorithm in (Liu et al., 2020), given in Algorithm 1.
The algorithm aims to minimize the mean loss function L(S, A) = 1"
PRELIMINARIES,0.1348973607038123,"N
PN
i=1 L(S, Ai), where S is the
learned sketch, L(S, A) is the loss function of S applied to a data matrix A, and A = {A1, . . . , AN}
is a (random) subset of training data."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.1378299120234604,"3
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.14076246334310852,"In this section we explain two ways to optimize the subspace embedding property of the sketching
matrix. One is to optimize the non-zero positions of the COUNT-SKETCH-type sketch, based on a
trained oracle to identify a superset of the rows of large leverage score. The other is to optimize the
values of the nonzero entries, which may no longer be ‚àí1 or 1, via a learning algorithm based on
gradient descent. As we shall see in Section 4 and 5, a better subspace embedding implies a better
convergence rate in the IHS, as well as for the subroutine in unconstrained convex optimization."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.1436950146627566,"3.1
SKETCHED LEARNING: OPTIMIZING THE POSITIONS"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.1466275659824047,"In this section we consider the problem of embedding the column space of a matrix A ‚ààRn√ód,
provided that A has a few rows of large leverage score, as well as access to an oracle which reveals a"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.1495601173020528,Under review as a conference paper at ICLR 2022
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.15249266862170088,"superset of the indices of such rows. Formally, let œÑi(A) denote the leverage score of the i-th row of
A and let
I‚àó= {i : œÑi(A) ‚â•ŒΩ}"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.15542521994134897,"be the set of rows with large leverage score. Suppose that a superset I ‚äáI‚àóis known to the algorithm.
In the experiments we train an oracle to predict such rows. We can maintain all rows in I explicitly
and apply a COUNT-SKETCH to the remaining rows, i.e., the rows in [n] \ I. Up to permutation of
the rows, we can write"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.15835777126099707,"A =

AI
AIc"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.16129032258064516,"
and
S =

I
0
0
S‚Ä≤"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.16422287390029325,"
,
(4)"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.16715542521994134,"where S‚Ä≤ is a random COUNT-SKETCH matrix of m rows. Clearly S has a single non-zero entry per
column. We have the following theorem, whose proof is postponed to Section A. Intuitively, the proof
for COUNT-SKETCH in (Clarkson & Woodruff, 2017) handles rows of large leverage score and rows
of small leverage score separately. The rows of large leverage score are to be perfectly hashed while
the rows of small leverage score will concentrate in the sketch by the Hanson-Wright inequality."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.17008797653958943,"Theorem 3.1. Let ŒΩ = œµ/d. Suppose that m = O((d/œµ2)(polylog(1/œµ) + log(1/Œ¥))), Œ¥ ‚àà(0, 1/m]
and d = ‚Ñ¶((1/œµ) polylog(1/œµ) log2(1/Œ¥)). Then, there exists a distribution on S of the form in (4)"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.17302052785923755,"with m + |I| rows such that Pr

‚àÄx ‚ààcolsp(A),
‚à•Sx‚à•2
2 ‚àí‚à•x‚à•2
2
 > œµ ‚à•x‚à•2
2
	
‚â§Œ¥ ."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.17595307917888564,"Hence, if there happen to be at most d polylog(1/œµ)/œµ2 rows of leverage score at least œµ/d, the
overall sketch length for embedding colsp(A) can be reduced to O((d polylog(1/œµ)+log(1/Œ¥))/œµ2),
a quadratic improvement in d and an exponential improvement in Œ¥ over the original sketch length
of O(d2/(œµ2Œ¥)) for COUNT-SKETCH. In the worst case there could be O(d2/œµ) such rows, though
empirically we do not observe this. The following is an immediate corollary, by setting Œ¥ = 1/m."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.17888563049853373,"Corollary 3.2. Suppose that d = ‚Ñ¶((1/œµ) polylog(1/œµ)) and |I| = O((d/œµ2) polylog(d/œµ)) with
ŒΩ = œµ/d. There exists a distribution on S of the form in (4) with O((d/œµ2) polylog(d/œµ)) rows such"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.18181818181818182,"that Pr

‚àÄx ‚ààcolsp(A),
‚à•Sx‚à•2
2 ‚àí‚à•x‚à•2
2
 > œµ ‚à•x‚à•2
2
	
‚â§œµ3 ."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.18475073313782991,"We remark that our S is of the COUNT-SKETCH type, which has a twofold beneÔ¨Åt. First, SA can be
applied in O(nnz(A)) time. This is faster than a chained subspace embedding of the form S2S1A,
where S1 is a COUNT-SKETCH matrix of O(d2/œµ2) rows and S2 is a subspace embedding matrix
of O(d/œµ2) rows. Computing S1A takes O(nnz(A)) time but computing S2(S1A) will take an
additional time of poly(d/œµ) or O(nnz(S1A) log(d)/œµ). The latter terms can be quite large and even
comparable to n if say, n is close to d2. Second, our S allows the sketched matrix SA to be sparse
when A is sparse, while the other designs such as Subsampled Randomized Hadamard Transforms
and Sparse Johnson-Lindentrauss Transforms either would not guarantee that SA is sparse, or would
yield a worse sparsity than a matrix of the COUNT-SKETCH type. The sparsity of SA is also important
for solving regression problems involving B = SA in intermediate steps, as algorithms such as
conjugate gradient, which use matrix-vector products, become more efÔ¨Åcient."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.187683284457478,"We note that approximate leverages scores of all rows can be found in time O(nnz(A) log n +
poly(d/œµ)) (Clarkson & Woodruff, 2017). Hence, one can approximate the leverage score of every
row in a preprocessing step before running the IHS. This time will be amortized by the IHS iterations,
because the matrix A remains the same throughout the process. Moreover, in Section 6, we show that
for a number of real-world datasets, it is possible to learn the indices of the heavy rows. In practice,
one can shrink the size of the superset I by restricting I to the rows with large ‚Ñì2 norms in AI. We
shall demonstrate in Section 6 that this heuristic works well on some real-world datasets."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.1906158357771261,"3.2
SKETCHED LEARNING: OPTIMIZING THE VALUES"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.1935483870967742,"As mentioned in Section 2, when we Ô¨Åx the positions of the non-zero entries, we aim to optimize
the values by gradient descent. We propose the following objective loss function for the learning
algorithm L(S, Ai) = ‚à•(AiRi)‚ä§AiRi ‚àíI‚à•F , over all the training data, where Ri comes from the
QR-decomposition of SAi = QiR‚àí1
i . We found empirically that not squaring this loss function
works better than squaring it. We think one of the reasons is that the version without squaring may
be less sensitive to outliers. The intuition for this loss function is given by the lemma below, whose
proof is deferred to Section B."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.19648093841642228,Under review as a conference paper at ICLR 2022
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.19941348973607037,"Lemma 3.3. Suppose that œµ ‚àà(0, 1"
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.20234604105571846,"2), S ‚ààRm√ón, A ‚ààRn√ód has full column rank, and SA = QR
is the QR-decomposition of SA. If ‚à•(AR‚àí1)‚ä§AR‚àí1 ‚àíI‚à•op ‚â§œµ, then S is a (1 ¬± œµ)-subspace
embedding of the column space of A."
LEARNING-AUGMENTED SUBSPACE EMBEDDINGS,0.20527859237536658,"Lemma 3.3 implies that if the loss function over Atrain is small and the distribution of Atest is similar
to Atrain, it is reasonable to expect that S is a good subspace embedding of Atest. Here we use the
Frobenius norm rather than operator norm in the loss function because it will make the optimization
problem easier to solve, and our empirical results also show that the performance of the Frobenius
norm is better than that of the operator norm."
HESSIAN SKETCH,0.20821114369501467,"4
HESSIAN SKETCH"
HESSIAN SKETCH,0.21114369501466276,Algorithm 2 Solver for (5)
HESSIAN SKETCH,0.21407624633431085,"1: S1 ‚Üêlearned sketch, S2 ‚Üêrandom sketch
2: ( bZi,1, bZi,2) ‚ÜêESTIMATE(Si, A), i = 1, 2"
HESSIAN SKETCH,0.21700879765395895,"3: i‚àó‚Üêarg mini=1,2( bZi,2/ bZi,1)
4: bx ‚Üêsolution of (5) with S = Si‚àó
5: return bx
6: function ESTIMATE(S, A)
7:
T ‚Üêsparse (1¬±Œ∑)-subspace embedding
matrix for d-dimensional subspaces
8:
(Q, R) ‚ÜêQR(TA)
9:
bZ1 ‚ÜêœÉmin(SAR‚àí1)
10:
bZ2 ‚Üê(1 ¬± Œ∑)-approximation to
(SAR‚àí1)‚ä§(SAR‚àí1) ‚àíI

op
11:
return ( bZ1, bZ2)"
HESSIAN SKETCH,0.21994134897360704,"In this section, we consider the minimization prob-
lem"
HESSIAN SKETCH,0.22287390029325513,"min
x‚ààC 1"
HESSIAN SKETCH,0.22580645161290322,"2 ‚à•SAx‚à•2
2 ‚àí‚ü®A‚ä§y, x‚ü©

,
(5)"
HESSIAN SKETCH,0.2287390029325513,"which is used as a subroutine for the IHS (cf. (2)).
We present an algorithm with the learned sketch
in Algorithm 2. To analyze its performance, we
deÔ¨Åne the following quantities (corresponding ex-
actly to the unconstrained case in (Pilanci & Wain-
wright, 2016))"
HESSIAN SKETCH,0.2316715542521994,"Z1(S) =
inf
v‚ààcolsp(A)‚à©Sn‚àí1 ‚à•Sv‚à•2
2 ,
Z2(S) =
sup
u,v‚ààcolsp(A)‚à©Sn‚àí1"
HESSIAN SKETCH,0.23460410557184752,"u, (S‚ä§S ‚àíIn)v

."
HESSIAN SKETCH,0.2375366568914956,"When S is a (1 + œµ)-subspace embedding of colsp(A), we have Z1(S) ‚â•1 ‚àíœµ and Z2(S) ‚â§2œµ."
HESSIAN SKETCH,0.2404692082111437,"For a general sketching matrix S, the following is the approximation guarantee of bZ1 and bZ2, which
are estimates of Z1(S) and Z2(S), respectively. The proof is postponed to Appendix C. The main
idea is that AR‚àí1 is well-conditioned, where R is as calculated in Algorithm 2.
Lemma 4.1. Suppose that Œ∑ ‚àà(0, 1"
HESSIAN SKETCH,0.2434017595307918,"3) is a small constant, A is of full rank and S has poly(d/Œ∑)
rows. The function ESTIMATE(S, A) returns in O((nnz(A) log 1"
HESSIAN SKETCH,0.24633431085043989,Œ∑ +poly( d
HESSIAN SKETCH,0.24926686217008798,"Œ∑)) time bZ1, bZ2 which with"
HESSIAN SKETCH,0.25219941348973607,probability at least 0.99 satisfy that Z1(S)
HESSIAN SKETCH,0.25513196480938416,1+Œ∑ ‚â§bZ1 ‚â§Z1(S)
HESSIAN SKETCH,0.25806451612903225,1‚àíŒ∑ and Z2(S)
HESSIAN SKETCH,0.26099706744868034,"(1+Œ∑)2 ‚àí3Œ∑ ‚â§bZ2 ‚â§
Z2(S)
(1‚àíŒ∑)2 + 3Œ∑."
HESSIAN SKETCH,0.26392961876832843,"Similar to Proposition 1 of (Pilanci & Wainwright, 2016), we have the following guarantee. The
proof is postponed to Appendix D.
Theorem 4.2. Let Œ∑ ‚àà(0, 1"
HESSIAN SKETCH,0.2668621700879765,"3) be a small constant. Suppose that A is of full rank and S1 and S2
are both COUNT-SKETCH-type sketches with poly(d/Œ∑) rows. Algorithm 2 returns a solution bx"
HESSIAN SKETCH,0.2697947214076246,"which, with probability at least 0.98, satisÔ¨Åes that ‚à•A(bx ‚àíx‚àó)‚à•2 ‚â§(1 + Œ∑)4
min
 b
Z1,2"
HESSIAN SKETCH,0.2727272727272727,"b
Z1,1 ,
b
Z2,2"
HESSIAN SKETCH,0.2756598240469208,"b
Z2,1 o
+"
HESSIAN SKETCH,0.2785923753665689,"4Œ∑

‚à•Ax‚àó‚à•2 in O(nnz(A) log( 1"
HESSIAN SKETCH,0.28152492668621704,Œ∑) + poly( d
HESSIAN SKETCH,0.2844574780058651,"Œ∑)) time, where x‚àó= arg minx‚ààC ‚à•Ax ‚àíb‚à•2 is the least-
squares solution."
HESSIAN SKETCH,0.2873900293255132,"Theorem 4.2 suggests the following. If the ratio of the learned sketch Z2(S1)/Z1(S1) is a constant
smaller than that of the random sketch Z2(S2)/Z2(S2) and Œ∑ is a constant fraction of the ratio
gap, then bZ1,2/ bZ1,1 is a constant smaller than bZ2,2/ bZ2,1, which means that the procedure of IHS
will converge faster with the learned sketch. In particular, if Si is a (1 + œµi)-subspace embedding
matrix for colsp(A) with œµi < 1/3 and Œ∑ < Œ≥ min{|œµ1 ‚àíœµ2|, œµ1, œµ2} for some small constant
Œ≥ > 0, we have Z2(Si)/Z1(Si) ‚â§3œµi and the guarantee in Theorem 4.2 becomes ‚à•A(bx ‚àíx‚àó)‚à•2 ‚â§
O(min{œµ1, œµ2}) ‚à•Ax‚àó‚à•2, that is, a better subspace embedding can lead to a faster convergence.
Hence, if the learned sketch is a better subspace embedding than a random sketch, theoretically we
can obtain a better convergence by setting Œ∑ small enough; in practice we shall observe this."
HESSIAN SKETCH,0.2903225806451613,"Furthermore, if we know the indices of the rows of large leverage scores of A and the assumptions
in Corollary 3.2 are satisÔ¨Åed, we can use O(d2/œµ2) rows to obtain a
 
1 + O(
œµ
‚àö"
HESSIAN SKETCH,0.2932551319648094,"d/ polylog(d/œµ))

-"
HESSIAN SKETCH,0.2961876832844575,"subspace embedding using Corollary 3.2, which is almost a
‚àö"
HESSIAN SKETCH,0.2991202346041056,d-factor better than the usual guarantee
HESSIAN SKETCH,0.3020527859237537,Under review as a conference paper at ICLR 2022
HESSIAN SKETCH,0.30498533724340177,"of a random COUNT-SKETCH matrix of the same dimension, leading to an algorithm of faster
convergence."
HESSIAN REGRESSION,0.30791788856304986,"5
HESSIAN REGRESSION"
HESSIAN REGRESSION,0.31085043988269795,Algorithm 3 Fast Regression Solver for (6)
HESSIAN REGRESSION,0.31378299120234604,"1: S1 ‚Üêlearned sketch, S2 ‚Üêrandom sketch
2: (Qi, Ri) ‚ÜêQR(SiA), i = 1, 2
3: (œÉi, œÉ‚Ä≤
i) ‚ÜêEIG(AR‚àí1
i ), i = 1, 2 ‚ñ∑EIG(B) returns
estimates of œÉmax(B) and œÉmin(B)
4: i‚àó‚Üêmini=1,2(œÉi/œÉ‚Ä≤
i)
5: P ‚ÜêR‚àí1
i‚àó
6: Œ∑ ‚Üê1/(œÉ2
i‚àó+ (œÉ‚Ä≤
i‚àó)2)
7: z0 ‚Üê0
8: while
A‚ä§APzt ‚àíy

2 ‚â•œµ ‚à•y‚à•2 do
9:
zt+1 ‚Üêzt ‚àíŒ∑(P ‚ä§A‚ä§AP)(P ‚ä§A‚ä§APzt‚àíP ‚ä§y)
10: return Pzt"
HESSIAN REGRESSION,0.31671554252199413,"In this section, we consider the minimiza-
tion problem"
HESSIAN REGRESSION,0.3196480938416422,"min
z
A‚ä§Az ‚àíy

2 ,
(6)"
HESSIAN REGRESSION,0.3225806451612903,"which is used as a subroutine for the un-
constrained convex optimization problem
minx f(x) with A‚ä§A being the Hessian
matrix ‚àá2f(x) (see (3)). Here A ‚ààRn√ód,
y ‚ààRd, and we have access to A. We incorporate a learned sketch into the fast regression solver in
(van den Brand et al., 2020) and present the algorithm in Algorithm 3."
HESSIAN REGRESSION,0.3255131964809384,"Here the subroutine EIG(B) applies a (1 + Œ∑)-subspace embedding sketch T to B for some small
constant Œ∑ and returns œÉmax(TB) and œÉmin(TB). Since B admits the form of AR, the sketched
matrix TB can be calculated as (TA)R and thus can be computed in O(nnz(A) + poly(d)) time if
T is a COUNT-SKETCH matrix of O(d2) rows. The extreme singular values of TB can be found by
SVD or the Lanczos algorithm."
HESSIAN REGRESSION,0.3284457478005865,"Similar to Lemma 4.2 in (van den Brand et al., 2020), we have the following guarantee of Algorithm 3.
The proof parallels the proof in (van den Brand et al., 2020) and is postponed to Appendix E.
Theorem 5.1. Suppose that S1 and S2 are both COUNT-SKETCH-type sketches with O(d2) rows.
Algorithm 3 returns a solution x‚Ä≤ such that ‚à•A‚ä§Ax‚Ä≤ ‚àíy‚à•2 ‚â§œµ ‚à•y‚à•2 with probability at least 0.97.
The runtime is O(nnz(A)) + eO(nd ¬∑ (min{œÉ1/œÉ‚Ä≤
1, œÉ2/œÉ‚Ä≤
2})2 ¬∑ log(Œ∫(A)/œµ) + poly(d)).
Remark 5.2. In Algorithm 3, S2 can be chosen to be a subspace embedding matrix for d-dimensional
subspaces, in which case, AR‚àí1
2
has condition number close to 1 (see, e.g., p38 of (Woodruff, 2014))
and the full algorithm would run faster than the trivial O(nd2)-time solver to (6).
Remark 5.3. For the original unconstrained convex optimization problem minx f(x), one can run
the entire optimization procedure with learned sketches versus the entire optimization procedure
with random sketches, compare the objective values at the end, and choose the better of the two.
For least-squares, f(x) = 1"
HESSIAN REGRESSION,0.3313782991202346,"2 ‚à•Ax ‚àíb‚à•2
2, and the value of f(x) can be approximated efÔ¨Åciently by a
sparse subspace embedding matrix in O(nnz(A) + nnz(b) + poly(d)) time."
EXPERIMENTS,0.3343108504398827,"6
EXPERIMENTS"
EXPERIMENTS,0.33724340175953077,"Comparison. We compare the learned sketch against three classical sketches: Gaussian, COUNT-
SKETCH, and SJLT (see Section 2) in all experiments. The quantity we compare is a certain error,
deÔ¨Åned individually for each problem, in each iteration of the IHS or the internal regression problem
in fast regression. All of our experiments are conducted on a laptop with a 1.90GHz CPU and 16GB
RAM. The ofÔ¨Çine training is done separately and the training of a single sketch matrix in our dataset
can be Ô¨Ånished within 5 minutes using a single GPU. For the learned sketches with learned values of
nonzero entries, we take an average over three independent trials; for all other sketches, we take an
average over Ô¨Åve independent trials. The details of the implementation are deferred to Appendix H."
EXPERIMENTS,0.34017595307917886,"We elaborate on the reason that the horizontal axes in the plots are in terms of iterations rather
than in terms of runtime. The learned matrix S is trained ofÔ¨Çine only once using the training
data. It is not computed while solving the optimization problem on the test data. Hence, no
additional computational cost is incurred in generating S other than solving the iteration step
using COUNT-SKETCH. Since Gaussian matrices and sparse JL transforms are denser than COUNT-
SKETCH matrices, they will be considerably slower in each round. Since we want to understand the
convergence behavior, an iteration count is more revealing than an overall time bound. If our learned
sketch performs no worse with respect to the total number of rounds (which our experiments show),
then it has an even greater advantage in runtime. To substantiate this claim, we show in Appendix F
an error-versus-runtime plot for the task of matrix estimation with nuclear norm constraints."
EXPERIMENTS,0.34310850439882695,Under review as a conference paper at ICLR 2022
EXPERIMENTS,0.3460410557184751,"6.1
IHS EXPERIMENTS: LASSO"
EXPERIMENTS,0.3489736070381232,We deÔ¨Åne an instance of LASSO regression to be:
EXPERIMENTS,0.3519061583577713,"x‚àó= arg min
‚à•x‚à•1‚â§Œª"
EXPERIMENTS,0.3548387096774194,"1
2 ‚à•Ax ‚àíb‚à•2
2 ,
(7)"
EXPERIMENTS,0.35777126099706746,where Œª is a parameter. We use two real-world datasets:
EXPERIMENTS,0.36070381231671556,"‚Ä¢ Electric2: residential electric load measurements. Each row of the matrix corresponds to
a different residence. Matrix columns are consecutive measurements from different times.
Ai ‚ààR370√ó9, bi ‚ààR370√ó1, and |(A, b)train| = 320, |(A, b)test| = 80. We set Œª = 15.
‚Ä¢ Greenhouse gas (GHG)3: time series of measured greenhouse gas concentrations in the Califor-
nia atmosphere. Each (A, b) corresponds to a different measurement location. Ai ‚ààR327√ó14,
bi ‚ààR327√ó1, and |(A, b)train| = 400, |(A, b)test| = 100. We set Œª = 30."
EXPERIMENTS,0.36363636363636365,"Experiment Setting: We choose m = 6d, 8d, 10d for both datasets.
We consider the error
1
2 ‚à•Ax ‚àíb‚à•2
2 ‚àí1"
EXPERIMENTS,0.36656891495601174,"2 ‚à•Ax‚àó‚àíb‚à•2
2. For the two datasets, we use both the methods proposed in Sec-
tion 3. For the heavy-row Count-Sketch, we allocate 30% of the sketch space to the rows of heavy
leverage score. For the Electric dataset, each row represents a speciÔ¨Åc residence and the indices of
the heavy rows do not vary much across the matrices in the training data. We select the heavy rows
according to the number of times each row is heavy in the training data for the heavy rows. We also
consider optimizing the non-zero values after identifying the heavy rows. For the GHG dataset, each
row represents a speciÔ¨Åc time point and the heavy rows are not very concentrated. Nevertheless, we
can Ô¨Ånd a superset of about 30% of the rows that contains most of the heavy rows, based on the
counts on the training data. Then we prune the superset by selecting the rows with the largest ‚Ñì2
norms, subject to the dimension budget. This will incur an additional computational cost, but the time
is almost the same as the time to read the sub-matrix of these rows, and it can be used in all iterations,
so the time of this step is negligible compared to the total runtime. We might lose a small fraction
of heavy rows, but it only negligibly affects the experiments. The distribution on the indices of the
heavy rows over the dataset is discussed in Appendix G."
EXPERIMENTS,0.36950146627565983,"Experimental Result: We plot in a logarithmic scale the mean errors of the two datasets in Figures 1
and 2. We see all methods display linear convergence, that is, letting ek denote the error in the k-th
iteration, we have ek ‚âàœÅke1 for some convergence rate œÅ. A smaller convergence rate implies a
faster convergence."
EXPERIMENTS,0.3724340175953079,"We calculate an estimated rate of convergence œÅ = (ek/e1)1/k with k = 10 for the GHG dataset, and
with k = 7 for the Electric dataset. For the GHG dataset, we can see that when the sketch size is
small (m = 6d), the gradient-based learned sketch has a rate of convergence that is 56% of that of
COUNT-SKETCH, and the heavy-rows sketch has a convergence rate that is 86.9%. When the sketch
size is large (m = 10d), the gradient-based learned sketch has a convergence rate that is 63.7%, and
the heavy-rows sketch is 82.1%. For the Electric dataset, both sketches, especially the heavy-rows
sketch, show signiÔ¨Åcant improvements. When the sketch size is small, the combined-learned sketch
has a convergence rate that is just 21.1% of that of sparse JL, and when the sketch size is large, the
combined-learned sketch has a smaller convergence rate that is just 15.4%."
EXPERIMENTS,0.375366568914956,"We also conducted IHS experiments for the matrix estimation problem with a nuclear norm constraint
in Appendix F."
EXPERIMENTS,0.3782991202346041,"2
4
6
8
10
iteration round 6 4 2 0 2"
EXPERIMENTS,0.3812316715542522,log_10(error)
EXPERIMENTS,0.3841642228739003,"learned(value-only)
count-sketch
learned(heavy rows)
gaussian
sparse-jl"
EXPERIMENTS,0.3870967741935484,"2
4
6
8
10
iteration round 6 4 2 0 2"
EXPERIMENTS,0.39002932551319647,log_10(error)
EXPERIMENTS,0.39296187683284456,"learned(value-only)
count-sketch
learned(heavy rows)
gaussian
sparse-jl"
EXPERIMENTS,0.39589442815249265,"1
2
3
4
5
6
7
8
9
iteration round 6 4 2 0 2"
EXPERIMENTS,0.39882697947214074,log_10(error)
EXPERIMENTS,0.40175953079178883,"learned(value-only)
count-sketch
learned(heavy rows)
gaussian
sparse-jl"
EXPERIMENTS,0.4046920821114369,Figure 1: Test error of LASSO in the Green House Gas dataset.
EXPERIMENTS,0.40762463343108507,"2https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014
3https://archive.ics.uci.edu/ml/datasets/Greenhouse+Gas+Observing+Network"
EXPERIMENTS,0.41055718475073316,Under review as a conference paper at ICLR 2022
EXPERIMENTS,0.41348973607038125,"1
2
3
4
5
6
7
iteration round 8 6 4 2 0 2"
EXPERIMENTS,0.41642228739002934,log_10(error)
EXPERIMENTS,0.41935483870967744,"learned(value-only)
count-sketch
learned(heavy rows)
gaussian
sparse-jl
learned(combined)"
EXPERIMENTS,0.4222873900293255,"1
2
3
4
5
6
7
iteration round 10 8 6 4 2 0 2"
EXPERIMENTS,0.4252199413489736,log_10(error)
EXPERIMENTS,0.4281524926686217,"learned(value-only)
count-sketch
learned(heavy rows)
gaussian
sparse-jl
learned(combined)"
EXPERIMENTS,0.4310850439882698,"1
2
3
4
5
6
7
iteration round 10 8 6 4 2 0 2"
EXPERIMENTS,0.4340175953079179,log_10(error)
EXPERIMENTS,0.436950146627566,"learned(value-only)
count-sketch
learned(heavy rows)
gaussian
sparse-jl
learned(combined)"
EXPERIMENTS,0.4398826979472141,Figure 2: Test error of LASSO in Electric dataset.
EXPERIMENTS,0.44281524926686217,"1.00
1.25
1.50
1.75
2.00
2.25
2.50
2.75
3.00
iteration round 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 error"
EXPERIMENTS,0.44574780058651026,"gaussian(eta = 1)
gaussian(eta = 0.2)
sparse-JL(eta = 1)
sparse-JL(eta = 0.2)
learned(heavy rows)"
EXPERIMENTS,0.44868035190615835,"1.00
1.25
1.50
1.75
2.00
2.25
2.50
2.75
3.00
iteration round 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 error"
EXPERIMENTS,0.45161290322580644,"gaussian(eta = 1)
gaussian(eta = 0.2)
sparse-JL(eta = 1)
sparse-JL(eta = 0.2)
learned(heavy rows)"
EXPERIMENTS,0.45454545454545453,"1.00
1.25
1.50
1.75
2.00
2.25
2.50
2.75
3.00
iteration round 0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00"
EXPERIMENTS,0.4574780058651026,"gaussian(eta = 1)
gaussian(eta = 0.2)
sparse-JL(eta = 1)
sparse-JL(eta = 0.2)
learned(heavy rows)"
EXPERIMENTS,0.4604105571847507,Figure 3: Test error of the subroutine in fast regression on Electric dataset.
FAST REGRESSION EXPERIMENTS,0.4633431085043988,"6.2
FAST REGRESSION EXPERIMENTS"
FAST REGRESSION EXPERIMENTS,0.4662756598240469,"2
4
6
8
10
12
14
iteration round 4 3 2 1 0 1 2 3 4"
FAST REGRESSION EXPERIMENTS,0.46920821114369504,log_10(error)
FAST REGRESSION EXPERIMENTS,0.47214076246334313,"gaussian
sparse-JL
learned(heavy rows)"
FAST REGRESSION EXPERIMENTS,0.4750733137829912,"Figure 4: Test error of fast regres-
sion on Electric dataset"
FAST REGRESSION EXPERIMENTS,0.4780058651026393,"We consider the unconstrained least squares problem minx f(x)
with f(x) = 1"
FAST REGRESSION EXPERIMENTS,0.4809384164222874,"2 ‚à•Ax ‚àíb‚à•2
2 using the Electric dataset."
FAST REGRESSION EXPERIMENTS,0.4838709677419355,"Training: Note that ‚àá2f(x) = A‚ä§A, independent of x. In
the t-th round of Newton‚Äôs method, by (3), we need to solve
a regression problem minz
A‚ä§Az ‚àíy
2
2 with y = ‚àáf(xt).
Hence, we can use the same two methods in the preceding
subsection to optimize the learned sketch Si. For a general
problem where ‚àá2f(x) depends on x, one can take xt to be the solution obtained from Algorithm 3
using the learned sketch St to generate A and y for the (t + 1)-st round, train a learned sketch St+1,
and repeat this process."
FAST REGRESSION EXPERIMENTS,0.4868035190615836,"Setup for Experiments: For the Electric dataset, we set m = 10d = 90. We compare the heavy-rows
COUNT-SKETCH matrix with the three classical random sketches, COUNT-SKETCH, Gaussian and
Sparse-JL. For the parameter Œ∑ in Algorithm 3, we set Œ∑ = 1 in all iterations for heavy-rows sketches.
For the classical random sketches, we set Œ∑ in the following two ways: (a) Œ∑ = 1 in all iterations and
(b) Œ∑ = 1 in the Ô¨Årst iteration and Œ∑ = 0.2 in all subsequent iterations."
FAST REGRESSION EXPERIMENTS,0.4897360703812317,"Experimental Results: We examine the accuracy of the subproblem (6) and deÔ¨Åne the error to
be
A‚ä§ARzt ‚àíy

2 / ‚à•y‚à•2. We consider the subproblems in the Ô¨Årst three iterations of the global
Newton method. The results are plotted in Figure 3. In this task, the COUNT-SKETCH causes a
terrible divergence of the subroutine and is thus omitted in the plots. Still, we observe that in setting
(a) of Œ∑, the other two classical sketches cause the subroutine to diverge. In setting (b) of Œ∑, the
other two classical sketches lead to convergence but their error is signiÔ¨Åcantly larger than that of the
heavy-rows sketches, in each of the Ô¨Årst three calls to the subroutine. The error of the heavy-rows
sketch is less than 0.01 in all iterations of all three subroutine calls, in both setting (a) and (b) of Œ∑."
FAST REGRESSION EXPERIMENTS,0.49266862170087977,"We also plot a Ô¨Ågure on the convergence of the global Newton method. Here, for each subroutine, we
only run one iteration, and plot the error of the original least squares problem. The result is shown in
Figure 4, which clearly displays a signiÔ¨Åcantly faster decay with heavy-rows sketches. The rate of
convergence using heavy-rows sketches is 80.6% of that using Gaussian or sparse JL sketches.
CONCLUSION. We demonstrated the superiority of using learned sketches over classical random
sketches, for the Iterative Hessian Sketch method which is used for a number of problems in
convex optimization. Compared with random sketches, our learned sketches of the same size yield
considerably faster convergence. We also provably show a better subspace embedding property of a
sketch of the same size given an oracle for predicting a superset of rows with large leverage score.
Our experiments show the construction of such an oracle is possible for real data sets, and they
demonstrate a signiÔ¨Åcant advantage over non-learned sketches for problems in convex optimization."
FAST REGRESSION EXPERIMENTS,0.49560117302052786,Under review as a conference paper at ICLR 2022
REFERENCES,0.49853372434017595,REFERENCES
REFERENCES,0.501466275659824,"Akshay Agrawal, Brandon Amos, Shane T. Barratt, Stephen P. Boyd, Steven Diamond, and J. Zico
Kolter. Differentiable convex optimization layers. In Advances in Neural Information Processing
Systems 32: Annual Conference on Neural Information Processing Systems 2019, NeurIPS 2019,
December 8-14, 2019, Vancouver, BC, Canada, pp. 9558‚Äì9570, 2019."
REFERENCES,0.5043988269794721,"Marcin Andrychowicz, Misha Denil, Sergio Gomez, Matthew W Hoffman, David Pfau, Tom Schaul,
Brendan Shillingford, and Nando De Freitas. Learning to learn by gradient descent by gradient
descent. In Advances in neural information processing systems, pp. 3981‚Äì3989, 2016."
REFERENCES,0.5073313782991202,"Jean Bourgain, Sjoerd Dirksen, and Jelani Nelson. Toward a uniÔ¨Åed theory of sparse dimensionality
reduction in Euclidean space. Geometric and Functional Analysis, pp. 1009‚Äì1088, 2015."
REFERENCES,0.5102639296187683,"Stephen Boyd and Lieven Vandenberghe. Convex Optimization. Cambridge University Press, 2004."
REFERENCES,0.5131964809384164,"Kenneth L. Clarkson and David P. Woodruff. Low-rank approximation and regression in input
sparsity time. J. ACM, 63(6), January 2017. ISSN 0004-5411. doi: 10.1145/3019134. URL
https://doi.org/10.1145/3019134."
REFERENCES,0.5161290322580645,"Michael B. Cohen. Nearly tight oblivious subspace embeddings by trace inequalities. In Proceedings
of the Twenty-Seventh Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ‚Äô16, pp.
278‚Äì287, USA, 2016. Society for Industrial and Applied Mathematics. ISBN 9781611974331."
REFERENCES,0.5190615835777126,"Graham Cormode and Charlie Dickens. Iterative hessian sketch in input sparsity time. In Proceedings
of 33rd Conference on Neural Information Processing Systems (NeurIPS), Vancouver, Canada,
2019."
REFERENCES,0.5219941348973607,"Nikita Doikov and Peter Richt√°rik. Randomized block cubic Newton method. In Proceedings of the
35th International Conference on Machine Learning, ICML 2018, Stockholmsm√§ssan, Stockholm,
Sweden, July 10-15, 2018, pp. 1289‚Äì1297, 2018."
REFERENCES,0.5249266862170088,"Yihe Dong, Piotr Indyk, Ilya P. Razenshteyn, and Tal Wagner. Learning space partitions for nearest
neighbor search. In 8th International Conference on Learning Representations, ICLR 2020, Addis
Ababa, Ethiopia, April 26-30, 2020, 2020."
REFERENCES,0.5278592375366569,"Robert M. Gower, Donald Goldfarb, and Peter Richt√°rik. Stochastic block BFGS: squeezing more
curvature out of data. In Proceedings of the 33nd International Conference on Machine Learning,
ICML 2016, New York City, NY, USA, June 19-24, 2016, pp. 1869‚Äì1878, 2016."
REFERENCES,0.530791788856305,"Robert M. Gower, Filip Hanzely, Peter Richt√°rik, and Sebastian U. Stich. Accelerated stochastic
matrix inversion: General theory and speeding up BFGS rules for faster second-order optimiza-
tion. In Advances in Neural Information Processing Systems 31: Annual Conference on Neural
Information Processing Systems 2018, NeurIPS 2018, 3-8 December 2018, Montr√©al, Canada, pp.
1626‚Äì1636, 2018."
REFERENCES,0.533724340175953,"Robert M. Gower, Dmitry Kovalev, Felix Lieder, and Peter Richt√°rik. RSN: randomized subspace
Newton. In Advances in Neural Information Processing Systems 32: Annual Conference on
Neural Information Processing Systems 2019, NeurIPS 2019, 8-14 December 2019, Vancouver,
BC, Canada, pp. 614‚Äì623, 2019."
REFERENCES,0.5366568914956011,"Chen-Yu Hsu, Piotr Indyk, Dina Katabi, and Ali Vakilian. Learning-based frequency estimation
algorithms. In 7th International Conference on Learning Representations, ICLR 2019, New
Orleans, LA, USA, May 6-9, 2019, 2019."
REFERENCES,0.5395894428152492,"Piotr Indyk, Ali Vakilian, and Yang Yuan. Learning-based low-rank approximations. In Advances in
Neural Information Processing Systems 32: Annual Conference on Neural Information Processing
Systems 2019, NeurIPS 2019, 8-14 December 2019, Vancouver, BC, Canada, pp. 7400‚Äì7410,
2019."
REFERENCES,0.5425219941348973,"Sudhir B. Kylasa, Fred (Farbod) Roosta, Michael W. Mahoney, and Ananth Grama. GPU accelerated
sub-sampled Newton‚Äôs method for convex classiÔ¨Åcation problems. In Proceedings of the 2019
SIAM International Conference on Data Mining, SDM 2019, Calgary, Alberta, Canada, May 2-4,
2019, pp. 702‚Äì710, 2019."
REFERENCES,0.5454545454545454,Under review as a conference paper at ICLR 2022
REFERENCES,0.5483870967741935,"Xiang Li, Shusen Wang, and Zhihua Zhang. Do subsampled newton methods work for high-
dimensional data? In The Thirty-Fourth AAAI Conference on ArtiÔ¨Åcial Intelligence, AAAI 2020,
The Thirty-Second Innovative Applications of ArtiÔ¨Åcial Intelligence Conference, IAAI 2020, The
Tenth AAAI Symposium on Educational Advances in ArtiÔ¨Åcial Intelligence, EAAI 2020, New York,
NY, USA, February 7-12, 2020, pp. 4723‚Äì4730. AAAI Press, 2020."
REFERENCES,0.5513196480938416,"Simin Liu, Tianrui Liu, Ali Vakilian, Yulin Wan, and David P. Woodruff. On learned sketches for
randomized numerical linear algebra. arXiv:2007.09890 [cs.LG], 2020. URL https://arxiv.org/abs/
2007.09890."
REFERENCES,0.5542521994134897,"J. Nelson and H. L. Nguy√™n. Osnap: Faster numerical linear algebra algorithms via sparser subspace
embeddings. In 2013 IEEE 54th Annual Symposium on Foundations of Computer Science, pp.
117‚Äì126, 2013."
REFERENCES,0.5571847507331378,"Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor
Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas K√∂pf, Edward
Yang, Zachary DeVito, Martin Raison, Alykhan Tejani, Sasank Chilamkurthy, Benoit Steiner,
Lu Fang, Junjie Bai, and Soumith Chintala. Pytorch: An imperative style, high-performance deep
learning library. In Advances in Neural Information Processing Systems 32: Annual Conference
on Neural Information Processing Systems 2019, NeurIPS 2019, December 8-14, 2019, Vancouver,
BC, Canada, pp. 8024‚Äì8035, 2019."
REFERENCES,0.5601173020527859,"Mert Pilanci and Martin J. Wainwright. Iterative Hessian sketch: Fast and accurate solution approxi-
mation for constrained least-squares. J. Mach. Learn. Res., 17:53:1‚Äì53:38, 2016."
REFERENCES,0.5630498533724341,"Mert Pilanci and Martin J. Wainwright. Newton sketch: A near linear-time optimization algorithm
with linear-quadratic convergence. SIAM J. Optim., 27(1):205‚Äì245, 2017."
REFERENCES,0.5659824046920822,"Farbod Roosta-Khorasani and Michael W. Mahoney. Sub-sampled Newton methods. Math. Program.,
174(1-2):293‚Äì326, 2019."
REFERENCES,0.5689149560117303,"T. Sarlos. Improved approximation algorithms for large matrices via random projections. In 2006
47th Annual IEEE Symposium on Foundations of Computer Science (FOCS‚Äô06), pp. 143‚Äì152,
2006."
REFERENCES,0.5718475073313783,"Jan van den Brand, Binghui Peng, Zhao Song, and Omri Weinstein. Training (overparametrized)
neural networksin near-linear time. arXiv:2006.11648 [cs.LG], 2020."
REFERENCES,0.5747800586510264,"Roman Vershynin. Introduction to the non-asymptotic analysis of random matrices. In Yonina C.
Eldar and Gitta Kutyniok (eds.), Compressed Sensing: Theory and Applications, pp. 210‚Äì268.
Cambridge University Press, 2012. doi: 10.1017/CBO9780511794308.006."
REFERENCES,0.5777126099706745,"David P. Woodruff. Sketching as a tool for numerical linear algebra. 10(1‚Äì2):1‚Äì157, October 2014.
ISSN 1551-305X. doi: 10.1561/0400000060. URL https://doi.org/10.1561/0400000060."
REFERENCES,0.5806451612903226,"Peng Xu, Jiyan Yang, Farbod Roosta-Khorasani, Christopher R√©, and Michael W. Mahoney. Sub-
sampled Newton methods with non-uniform sampling. In Advances in Neural Information Process-
ing Systems 29: Annual Conference on Neural Information Processing Systems 2016, December
5-10, 2016, Barcelona, Spain, pp. 3000‚Äì3008, 2016."
REFERENCES,0.5835777126099707,"Peng Xu, Fred Roosta, and Michael W. Mahoney. Second-order optimization for non-convex machine
learning: an empirical study. In Proceedings of the 2020 SIAM International Conference on Data
Mining, SDM 2020, Cincinnati, Ohio, USA, May 7-9, 2020, pp. 199‚Äì207, 2020."
REFERENCES,0.5865102639296188,Under review as a conference paper at ICLR 2022
REFERENCES,0.5894428152492669,"A
PROOF OF THEOREM 3.1"
REFERENCES,0.592375366568915,"First we prove the following lemma.
Lemma A.1. Let Œ¥ ‚àà(0, 1/m]. It holds with probability at least 1 ‚àíŒ¥ that"
REFERENCES,0.5953079178885631,"sup
x‚ààcolsp(A)"
REFERENCES,0.5982404692082112,"‚à•Sx‚à•2
2 ‚àí‚à•x‚à•2
2
 ‚â§œµ ‚à•x‚à•2
2 ,"
REFERENCES,0.6011730205278593,provided that
REFERENCES,0.6041055718475073,"m ‚â≥œµ‚àí2((d + log m) min{log2(d/œµ), log2 m} + d log(1/Œ¥)),"
REFERENCES,0.6070381231671554,"1 ‚â≥œµ‚àí2ŒΩ((log m) min{log2(d/œµ), log2 m} + log(1/Œ¥)) log(1/Œ¥)."
REFERENCES,0.6099706744868035,"Proof. We shall adapt the proof of Theorem 5 in (Bourgain et al., 2015) to our setting. Let T
denote the unit sphere in colsp(A) and set the sparsity parameter s = 1. Observe that ‚à•Sx‚à•2
2 =
‚à•xI‚à•2
2 + ‚à•SxIc‚à•2
2, and so it sufÔ¨Åces to show that"
REFERENCES,0.6129032258064516,"Pr
n‚à•S‚Ä≤xIc‚à•2
2 ‚àí‚à•xIc‚à•2
2
 > œµ
o
‚â§Œ¥"
REFERENCES,0.6158357771260997,"for x ‚ààT. We make the following deÔ¨Ånition, as in (2.6) of Bourgain et al. (2015):"
REFERENCES,0.6187683284457478,"AŒ¥,x := m
X i=1 X"
REFERENCES,0.6217008797653959,"j‚ààIc
Œ¥ijxjei ‚äóej,"
REFERENCES,0.624633431085044,"and thus, S‚Ä≤xIc = AŒ¥,xœÉ. Also by E ‚à•S‚Ä≤xIc‚à•2
2 = ‚à•xIc‚à•2
2, one has"
REFERENCES,0.6275659824046921,"sup
x‚ààT"
REFERENCES,0.6304985337243402,"‚à•S‚Ä≤xIc‚à•2
2 ‚àí‚à•xIc‚à•2
2
 = sup
x‚ààT"
REFERENCES,0.6334310850439883,"‚à•AŒ¥,xœÉ‚à•2
2 ‚àíE ‚à•AŒ¥,xœÉ‚à•2
2
 .
(8)"
REFERENCES,0.6363636363636364,"Now, in (2.7) of Bourgain et al. (2015) we instead deÔ¨Åne a seminorm"
REFERENCES,0.6392961876832844,"‚à•x‚à•Œ¥ = max
1‚â§i‚â§m Ô£´ Ô£≠X"
REFERENCES,0.6422287390029325,"j‚ààIc
Œ¥ijx2
j Ô£∂ Ô£∏ 1/2 ."
REFERENCES,0.6451612903225806,"Then (2.8) continues to hold, and (2.9) as well as (2.10) continue to hold if the supremum in the
left-hand side is replaced with the left-hand side of (8). At the beginning of Theorem 5, we deÔ¨Åne
U (i) to be U, but each row j ‚ààIc is multiplied by Œ¥ij and each row j ‚ààI is zeroed out. Then we
have in the Ô¨Årst step of (4.5) that X"
REFERENCES,0.6480938416422287,"j‚ààIc
Œ¥ij  d
X"
REFERENCES,0.6510263929618768,"k=1
gk‚ü®fk, ej‚ü©  2"
REFERENCES,0.6539589442815249,"‚â§
U (i)g

2 2 ,"
REFERENCES,0.656891495601173,"instead of equality. One can verify that the rest of (4.5) goes through. It remains true that ‚à•¬∑‚à•Œ¥ ‚â§
(1/‚àös) ‚à•¬∑‚à•2, and thus (4.6) holds. One can verify that the rest of the proof of Theorem 5 in Bourgain
et al. (2015) continues to hold if we replace Pn
j=1 with P
j‚ààIc and max1‚â§j‚â§n with maxj‚ààIc, noting
that
E
X"
REFERENCES,0.6598240469208211,"j‚ààIc
Œ¥ij ‚à•PEej‚à•2
2 = s m X"
REFERENCES,0.6627565982404692,"j‚ààIc
‚ü®PEej, ej‚ü©‚â§s md"
REFERENCES,0.6656891495601173,"and
E(U (i))‚àóU (i) =
X"
REFERENCES,0.6686217008797654,"j‚ààIc
(EŒ¥ij)uju‚àó
j ‚™Ø1 m."
REFERENCES,0.6715542521994134,"Thus, the symmetrization inequalities on X"
REFERENCES,0.6744868035190615,"j‚ààIc
Œ¥ij ‚à•PEej‚à•2
2 Lp
Œ¥ and  X"
REFERENCES,0.6774193548387096,"j‚ààIc
Œ¥ijuju‚àó
j Lp
Œ¥"
REFERENCES,0.6803519061583577,"continue to hold. The result then follows, observing that maxj‚ààIc ‚à•PEej‚à•2 ‚â§ŒΩ."
REFERENCES,0.6832844574780058,Under review as a conference paper at ICLR 2022
REFERENCES,0.6862170087976539,The subspace embedding guarantee now follows as a corollary.
REFERENCES,0.6891495601173021,"Theorem 3.1. Let ŒΩ = œµ/d. Suppose that m = ‚Ñ¶((d/œµ2)(polylog(1/œµ) + log(1/Œ¥))), Œ¥ ‚àà(0, 1/m)
and d = ‚Ñ¶((1/œµ) polylog(1/œµ) log2(1/Œ¥)). Then, there exists a distribution on S with m + |I| rows
such that
Pr
n
‚àÄx ‚ààcolsp(A),
‚à•Sx‚à•2
2 ‚àí‚à•x‚à•2
2
 > œµ ‚à•x‚à•2
2
o
‚â§Œ¥."
REFERENCES,0.6920821114369502,Proof. One can verify that the two conditions in Lemma A.1 are satisÔ¨Åed if m ‚â≥d œµ2
REFERENCES,0.6950146627565983,"
polylog(d"
REFERENCES,0.6979472140762464,"œµ ) + log 1 Œ¥ 
, d ‚â≥1 œµ"
REFERENCES,0.7008797653958945,"
log 1 Œ¥"
REFERENCES,0.7038123167155426," 
polylog(d"
REFERENCES,0.7067448680351907,"œµ ) + log 1 Œ¥ 
."
REFERENCES,0.7096774193548387,The last condition is satisÔ¨Åed if d ‚â≥1 œµ
REFERENCES,0.7126099706744868,"
log2 1 Œ¥"
REFERENCES,0.7155425219941349,"
polylog
1 œµ 
."
REFERENCES,0.718475073313783,"B
PROOF OF LEMMA 3.3"
REFERENCES,0.7214076246334311,"Proof. On the one hand, since Q = SAR is an orthogonal matrix, we have"
REFERENCES,0.7243401759530792,"‚à•x‚à•2 = ‚à•Qx‚à•2 = ‚à•SARx‚à•2 .
(9)"
REFERENCES,0.7272727272727273,"On the other hand, the assumption implies that
(ARx)T (ARx) ‚àíxT x

2 ‚â§œµ ‚à•x‚à•2
2 ,"
REFERENCES,0.7302052785923754,"that is,
(1 ‚àíœµ) ‚à•x‚à•2
2 ‚â§‚à•ARx‚à•2
2 ‚â§(1 + œµ) ‚à•x‚à•2
2 .
(10)"
REFERENCES,0.7331378299120235,"Combining both (9) and (10) leads to
‚àö"
REFERENCES,0.7360703812316716,"1 ‚àíœµ ‚à•SARx‚à•2 ‚â§‚à•ARx‚à•2 ‚â§
‚àö"
REFERENCES,0.7390029325513197,"1 + œµ ‚à•SARx‚à•2 ,
‚àÄx ‚ààRd"
REFERENCES,0.7419354838709677,"Equivalently, it can be written as"
REFERENCES,0.7448680351906158,"1
‚àö1 + œµ ‚à•SAy‚à•2 ‚â§‚à•Ay‚à•2 ‚â§
1
‚àö1 ‚àíœµ ‚à•SAy‚à•2 ,
‚àÄy ‚ààRd."
REFERENCES,0.7478005865102639,"The claimed result follows from the fact that 1/‚àö1 + œµ ‚â•1 ‚àíœµ and 1/‚àö1 ‚àíœµ ‚â§1 + œµ whenever
œµ ‚àà(0,
‚àö 5‚àí1 2
]."
REFERENCES,0.750733137829912,"C
PROOF OF LEMMA 4.1"
REFERENCES,0.7536656891495601,"Suppose that AR‚àí1 = UW, where U ‚ààRn√ód has orthonormal columns, which form an orthonormal
basis of the column space of A. Since T is a subspace embedding of the column space of A with
probability 0.99, it holds for all x ‚ààRd that"
REFERENCES,0.7565982404692082,"1
1 + Œ∑"
REFERENCES,0.7595307917888563,"TAR‚àí1x

2 ‚â§
AR‚àí1x

2 ‚â§
1
1 ‚àíŒ∑"
REFERENCES,0.7624633431085044,"TAR‚àí1x

2 ."
REFERENCES,0.7653958944281525,"Since
TAR‚àí1x

2 = ‚à•Qx‚à•2 = ‚à•x‚à•2
and
‚à•Wx‚à•2 = ‚à•UWx‚à•2 =
AR‚àí1x

2
(11)"
REFERENCES,0.7683284457478006,"we have that
1
1 + Œ∑ ‚à•x‚à•2 ‚â§‚à•Wx‚à•2 ‚â§
1
1 ‚àíŒ∑ ‚à•x‚à•2 ,
x ‚ààRd.
(12)"
REFERENCES,0.7712609970674487,Under review as a conference paper at ICLR 2022
REFERENCES,0.7741935483870968,It is easy to see that
REFERENCES,0.7771260997067448,"Z1(S) = min
x‚ààSd‚àí1 ‚à•SUx‚à•2 = min
yÃ∏=0
‚à•SUWy‚à•2"
REFERENCES,0.7800586510263929,"‚à•Wy‚à•2
,"
REFERENCES,0.782991202346041,"and thus,"
REFERENCES,0.7859237536656891,"min
yÃ∏=0(1 ‚àíŒ∑)‚à•SUWy‚à•2"
REFERENCES,0.7888563049853372,"‚à•y‚à•2
‚â§Z1(S) ‚â§min
yÃ∏=0(1 + Œ∑)‚à•SUWy‚à•2"
REFERENCES,0.7917888563049853,"‚à•y‚à•2
."
REFERENCES,0.7947214076246334,"Recall that SUW = SAR‚àí1. We see that
(1 ‚àíŒ∑)œÉmin(SAR‚àí1) ‚â§Z1(S) ‚â§(1 + Œ∑)œÉmin(SAR‚àí1)."
REFERENCES,0.7976539589442815,"By deÔ¨Ånition,
Z2(S) =
U T (S‚ä§S ‚àíIn)U

op .
It follows from (12) that
(1 ‚àíŒ∑)2 W T U T (ST S ‚àíIn)UW

op ‚â§Z2(S) ‚â§(1 + Œ∑)2 W T U T (ST S ‚àíIn)UW

op ."
REFERENCES,0.8005865102639296,"and from (12), (11) and Lemma 5.36 of Vershynin (2012) that
(AR‚àí1)‚ä§(AR‚àí1) ‚àíI

op ‚â§3Œ∑."
REFERENCES,0.8035190615835777,"Since
W T U T (ST S ‚àíIn)UW

op =
(AR‚àí1)‚ä§(ST S ‚àíIn)AR‚àí1
op
and
(AR‚àí1)‚ä§ST SAR‚àí1 ‚àíI

op ‚àí
(AR‚àí1)‚ä§(AR‚àí1) ‚àíI

op
‚â§
(AR‚àí1)‚ä§(ST S ‚àíIn)AR‚àí1
op
‚â§
(AR‚àí1)‚ä§ST SAR‚àí1 ‚àíI

op +
(AR‚àí1)‚ä§(AR‚àí1) ‚àíI

op ,"
REFERENCES,0.8064516129032258,"it follows that
(1 ‚àíŒ∑)2 (SAR‚àí1)‚ä§SAR‚àí1 ‚àíI

op ‚àí3(1 ‚àíŒ∑)2Œ∑"
REFERENCES,0.8093841642228738,‚â§Z2(S)
REFERENCES,0.8123167155425219,"‚â§(1 + Œ∑)2 (SAR‚àí1)‚ä§SAR‚àí1 ‚àíI

op + 3(1 + Œ∑)2Œ∑."
REFERENCES,0.8152492668621701,We have so far proved the correctness of the approximation and we shall analyze the runtime below.
REFERENCES,0.8181818181818182,"Since S and T are sparse, computing SA and TA takes O(nnz(A)) time. The QR decomposition
of TA, which is a matrix of size poly(d/Œ∑) √ó d, can be computed in poly(d/Œ∑) time. The matrix
SAR‚àí1 can be computed in poly(d) time. Since it has size poly(d/Œ∑) √ó d, its smallest singular
value can be computed in poly(d/Œ∑) time. To approximate Z2(S), we can use the power method to
estimate
(SAR‚àí1)T SAR‚àí1 ‚àíI

op up to a (1 ¬± Œ∑)-factor in O((nnz(A) + poly(d/Œ∑)) log(1/Œ∑))
time."
REFERENCES,0.8211143695014663,"D
PROOF OF THEOREM 4.2"
REFERENCES,0.8240469208211144,"In Lemma 4.1, we have with probability at least 0.99 that
bZ2
bZ1
‚â•"
REFERENCES,0.8269794721407625,"1
(1+Œ∑)2 Z2(S) ‚àí3Œ∑"
REFERENCES,0.8299120234604106,"1
1‚àíŒ∑Z1(S)
‚â•
1 ‚àíŒ∑
(1 + Œ∑)2
Z2(S)
Z1(S) ‚àí
3Œ∑
Z1(S)."
REFERENCES,0.8328445747800587,"When S is random subspace embedding, it holds with probability at least 0.99 that Z1(S) ‚â•3/4 and
so, by a union bound, it holds with probability at least 0.98 that
bZ2
bZ1
‚â•
1
(1 + Œ∑)4
Z2(S)
Z1(S) ‚àí4Œ∑,"
REFERENCES,0.8357771260997068,"or,
Z2(S)
Z1(S) ‚â§(1 + Œ∑)4
 bZ2"
REFERENCES,0.8387096774193549,"bZ1
+ 4Œ∑ ! ."
REFERENCES,0.841642228739003,"The correctness of our claim then follows from Proposition 1 of Pilanci & Wainwright (2016),
together with the fact that S2 is a random subspace embedding. The runtime follows from Lemma 4.1
and Theorem 2.2 of Cormode & Dickens (2019)."
REFERENCES,0.844574780058651,Under review as a conference paper at ICLR 2022
REFERENCES,0.8475073313782991,"E
PROOF OF THEOREM 5.1"
REFERENCES,0.8504398826979472,"The proof follows a similar argument to that in (van den Brand et al., 2020, Lemma B.1). In van den
Brand et al. (2020), it is assumed (in our notation) that 3/4 ‚â§œÉmin(AP) ‚â§œÉmax(AP) ‚â§5/4
and thus one can set Œ∑ = 1 in Algorithm 3 and achieve a linear convergence. The only dif-
ference is that here we estimate œÉmin(AP) and œÉmax(AP) and set the step size Œ∑ in the gradi-
ent descent algorithm accordingly. By standard bounds for gradient descent (see, e.g., p468 of
Boyd & Vandenberghe (2004)), with a choice of step size Œ∑ = 2/(œÉ2
max(AP) + œÉ2
min(AP)), after
O((œÉmax(AP)/œÉmin(AP))2 log(1/œµ)) iterations, we can Ô¨Ånd zt such that
P ‚ä§A‚ä§AP(zt ‚àíz‚àó)

2 ‚â§œµ
P ‚ä§A‚ä§AP(z0 ‚àíz‚àó)

2 ,"
REFERENCES,0.8533724340175953,"where z‚àó= arg minz
P ‚ä§A‚ä§APz ‚àíP ‚ä§y

2 is the optimal least-squares solution. This establishes
Eq. (11) in the proof in van den Brand et al. (2020), and the rest of the proof follows as in there."
REFERENCES,0.8563049853372434,"We use three subspace embeddings here, S1, S2 and one used in the EIG subrountine. Each subspace
embedding uses O(d2) rows with a constant distortion parameter and a failure probability of 0.01.
The overall failure probability is thus 0.03."
REFERENCES,0.8592375366568915,"F
IHS EXPERIMENTS: MATRIX ESTIMATION WITH NUCLEAR NORM
CONSTRAINT"
REFERENCES,0.8621700879765396,"In many applications, for the problem"
REFERENCES,0.8651026392961877,"X‚àó:= arg min
X‚ààRd1√ód2
‚à•AX ‚àíB‚à•2
F ,"
REFERENCES,0.8680351906158358,"it is reasonable to model the matrix X‚àóas having low rank. Similar to the ‚Ñì1-minimization for
compressive sensing, a standard relaxation of the rank constraint is to minimize the nuclear norm of
X, deÔ¨Åned as ‚à•X‚à•‚àó:= Pmin{d1,d2}
j=1
œÉj(X), where œÉj(X) is the j-th largest singular value of X."
REFERENCES,0.8709677419354839,"Hence, the matrix estimation problem we consider here is"
REFERENCES,0.873900293255132,"X‚àó:= arg min
X‚ààRd1√ód2
‚à•AX ‚àíB‚à•2
F
such that
‚à•X‚à•‚àó‚â§œÅ,"
REFERENCES,0.8768328445747801,where œÅ > 0 is a user-deÔ¨Åned radius as a regularization parameter.
REFERENCES,0.8797653958944281,We conduct experiments on the following datasets:
REFERENCES,0.8826979472140762,"‚Ä¢ Tunnel4: The data set is a time series of gas concentrations measured by eight sensors in a
wind tunnel. Each (A, B) corresponds to a different data collection trial. Ai ‚ààR13530√ó5, Bi ‚àà
R13530√ó6, |(A, B)|train = 144, |(A, B)|test = 36. In our nuclear norm constraint, we set
œÅ = 10."
REFERENCES,0.8856304985337243,"Experiment Setting: We choose m = 7d, 10d for the Tunnel dataset. We consider the error
1
2 ‚à•AX ‚àíB‚à•2
2 ‚àí1"
REFERENCES,0.8885630498533724,"2 ‚à•AX‚àó‚àíB‚à•2
2. The leverage scores of this dataset are very uniform. Hence, for
this experiment we only consider optimizing the values of the non-zero entries."
REFERENCES,0.8914956011730205,"Results of Our Experiments: We plot in a logarithmic scale the mean errors of the two datasets in
Figures 5. We can see that when m = 7d, the gradient-based sketch, based on the Ô¨Årst 6 iterations,
has a rate of convergence that is 48% of the random sketch, and when m = 10d, the gradient-based
sketch has a rate of convergence that is 29% of the random sketch."
REFERENCES,0.8944281524926686,"Runtime of Learned Sketch.
As stated in Section 2, our learned sketch matrices S are all COUNT-
SKETCH-type matrices (each column contains a single nonzero entry), the matrix product SA can
thus be computed in O(nnz(A)) time and the overall algorithm is expected to be fast. To verify this,
we plot in an error-versus-runtime plot for matrix estimation with nuclear norm constraint tasks with
m = 10d in Figures 6 (corresponding to the datasets in Figure 5). The runtime consists only of the
time for sketching and solving the optimization problem and does not include the time for loading the
data. We run the same experiment three times. Each time we take an average over all test data. From
the plot we can observe that the learned sketch and COUNT-SKETCH have the fastest runtimes, which
are slightly faster than that of the SJLT and signiÔ¨Åcantly faster than that of the Gaussian sketch."
REFERENCES,0.8973607038123167,4https://archive.ics.uci.edu/ml/datasets/Gas+sensor+array+exposed+to+turbulent+gas+mixtures
REFERENCES,0.9002932551319648,Under review as a conference paper at ICLR 2022
REFERENCES,0.9032258064516129,"2
4
6
8
10
iteration round 5 4 3 2 1 0 1 2 3"
REFERENCES,0.906158357771261,log_10(error)
REFERENCES,0.9090909090909091,"learned(value-only)
count-sketch
gaussian
sparse JL"
REFERENCES,0.9120234604105572,"1
2
3
4
5
6
7
8
9
iteration round 8 6 4 2 0 2"
REFERENCES,0.9149560117302052,log_10(error)
REFERENCES,0.9178885630498533,"learned(value-only)
count-sketch
gaussian
sparse JL"
REFERENCES,0.9208211143695014,Figure 5: Test error of matrix estimation with nuclear norm constraint on Tunnel dataset
REFERENCES,0.9237536656891495,"0.1
0.2
0.3
0.4
0.5
runtime 8 6 4 2 0 2"
REFERENCES,0.9266862170087976,log(error)
REFERENCES,0.9296187683284457,"learned
count-sketch
gaussian
sparse JL"
REFERENCES,0.9325513196480938,Figure 6: Test error of matrix estimation with nuclear norm constraint on Tunnel dataset
REFERENCES,0.9354838709677419,"G
HEAVY LEVERAGE SCORE ROWS DISTRIBUTION OVER THE DATASET"
REFERENCES,0.9384164222873901,"In our experiments, we hypothesize that in real-world data that there may be an underlying pattern
which can help us identify the heavy rows. In the Electric dataset, each row of the matrix corresponds
to a speciÔ¨Åc residence and the heavy rows are always concentrated on some speciÔ¨Åc rows; in the
GHG data set, each row corresponds to a speciÔ¨Åc time point and we can select some speciÔ¨Åc time
points to be a superset of the heavy rows and then select the heavy rows based on their ‚Ñì2-norm in
this superset."
REFERENCES,0.9413489736070382,"To exemplify this, we study the heavy leverage score rows distribution over the Electirc dataset. For
a row i ‚àà[370], let fi denote the times that row i is heavy out of 320 training data points from the
Electric dataset, where we say row i is heavy if ‚Ñìi ‚â•5d/n. Below we list all 74 pairs (i, fi) with
fi > 0."
REFERENCES,0.9442815249266863,"(195,320), (278,320), (361,320), (207,317), (227,285), (240,284), (219,270), (275,232), (156,214),
(322,213), (193,196), (190,192), (160,191), (350,181), (63,176), (42,168), (162,148), (356,129),
(363,110), (362,105), (338,95), (215,94), (234,93), (289,81), (97,80), (146,70), (102,67), (98,58),
(48,57), (349,53), (165,46), (101,41), (352,40), (293,34), (344,29), (268,21), (206,20), (217,20),
(327,20), (340,19), (230,18), (359,18), (297,14), (357,14), (161,13), (245,10), (100,8), (85,6), (212,6),
(313,6), (129,5), (130,5), (366,5), (103,4), (204,4), (246,4), (306,4), (138,3), (199,3), (222,3), (360,3),
(87,2), (154,2), (209,2), (123,1), (189,1), (208,1), (214,1), (221,1), (224,1), (228,1), (309,1), (337,1),
(343,1)"
REFERENCES,0.9472140762463344,"Observe that the heavy rows are concentrated on a set of speciÔ¨Åc row indices. There are only 30 rows
i with fi ‚â•50. We view this as strong evidence for our hypothesis."
REFERENCES,0.9501466275659824,"H
IMPLEMENTATION DETAILS"
REFERENCES,0.9530791788856305,"As we state in Section 3.2, when we Ô¨Åx the positions of the non-zero entries (uniformly chosen in
each column or sampling according to the heavy leverage score distribution), we aim to optimize the
values by gradient descent mentioned in Algorithm 1. Here the loss function is given in Section 3.2.
In our implementation, we use PyTorch (Paszke et al. (2019)), which can compute the gradient
automatically (here we can use torch.qr() and torch.svd() to deÔ¨Åne our loss function). For a more"
REFERENCES,0.9560117302052786,Under review as a conference paper at ICLR 2022
REFERENCES,0.9589442815249267,"nuanced loss function, which may be beneÔ¨Åcial, one can use the package released in Agrawal et al.
(2019), where the authors studied the problem of computing the gradient of functions which involve
the solution to certain convex optimization problem."
REFERENCES,0.9618768328445748,"As mentioned in Section 2, each column of the sketch matrix S has exact one non-zero entry.
Hence, the i-th coordinate of p can be seen as the non-zero position of the i-th column of S. In
the implementation, to sample p randomly, we can sample a random integer in {1, . . . , m} for each
coordinate of p. For the heavy rows mentioned in Section 3.1, we can allocate positions 1, . . . , k to
the k heavy rows, and for the other rows, we randomly sample an integer in {k + 1, . . . , m}. We note
that once the vector p, which contains the information of the nonzero position in each column of S, is
chosen, it will not be changed during the optimization process in Algorithm 1."
REFERENCES,0.9648093841642229,"Next, we introduce some parameters for our experiments."
REFERENCES,0.967741935483871,"‚Ä¢ bs: batch size, the number of training samples used in one iteration."
REFERENCES,0.9706744868035191,‚Ä¢ lr: learning rate of the gradient descent(the Œ± in Algorithm 1).
REFERENCES,0.9736070381231672,‚Ä¢ iter: the number of iteration for Algorithm 1.
REFERENCES,0.9765395894428153,"In our experiments, we set bs = 20, iter = 1000 for all dataset. We set lr = 10 for the Green House
Gas dataset and lr = 0.1 for the Electric dataset."
REFERENCES,0.9794721407624634,"I
ADDITIONAL EXPERIMENTS FOR LASSO"
REFERENCES,0.9824046920821115,"In this section, we consider the IHS experiments for LASSO on data of a larger size. The experiment
setting is the same as that in Section 6. We conduct our experiments on the following dataset:"
REFERENCES,0.9853372434017595,"‚Ä¢ Gas Sensor.5
A chemical detection platform composed of 8 chemoresistive gas sen-
sors was exposed to turbulent gas mixtures generated naturally in a wind tunnel. Each
matrix represents the measurements at dense time points during a short time period.
Ai ‚ààR95000√ó19, bi ‚ààR95000√ó1, and |(A, b)train| = 30, |(A, b)test| = 9. We set Œª = 10."
REFERENCES,0.9882697947214076,"The results are shown in Table 1. Here we choose m = 300. The leverage scores of the rows on this
dataset is very uniform hence we choose random positions for the nonzero entries and only optimize
the values in the learned sketch. For a matrix of such size, the gaussian sketching matrix is extremely
slow, hence, we only consider the Count-Sketch matrix and the Sparse-JL matrix. From the table
below we can see that the gradient-based learned sketch has a converge rate that is 74.6% of that of
the random sketch."
REFERENCES,0.9912023460410557,"Table 1: Error of the Sketch Matrix on Gas Senser data
Iteration
4
5
6
7
8
9
10
Learnd(value-only)
428.13
23.72
1.72
0.092
0.0060
0.00036
1.8 ¬∑ 10‚àí5"
REFERENCES,0.9941348973607038,"Count-Sketch
1864.66
122.26
12.30
1.46
0.074
0.013
0.00036
Sparse-JL
1897.32
188.31
9.60
1.30
0.16
0.0098
0.00048"
REFERENCES,0.9970674486803519,5https://archive.ics.uci.edu/ml/datasets/Gas+sensor+array+temperature+modulation
