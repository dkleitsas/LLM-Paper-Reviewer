Section,Section Appearance Order,Paragraph
ABSTRACT,0.0,ABSTRACT
ABSTRACT,0.001122334455667789,"We present a new, stochastic variant of the projective splitting (PS) family of
algorithms for monotone inclusion problems. It can solve min-max and noncoop-
erative game formulations arising in applications such as robust ML without the
convergence issues associated with gradient descent-ascent, the current de facto
standard approach in ML applications. Our proposal is the ﬁrst version of PS able
to use stochastic gradient oracles. It can solve min-max games while handling
multiple constraints and nonsmooth regularizers via projection and proximal op-
erators. Unlike other stochastic splitting methods that can solve such problems,
our method does not rely on a product-space reformulation of the original problem.
We prove almost-sure convergence of the iterates to the solution and a convergence
rate for the expected residual. By working with monotone inclusions rather than
variational inequalities, our analysis avoids the drawbacks of measuring conver-
gence through the restricted gap function. We close with numerical experiments on
a distributionally robust sparse logistic regression problem."
INTRODUCTION,0.002244668911335578,"1
INTRODUCTION"
INTRODUCTION,0.003367003367003367,"The most prominent application of optimization in ML is empirical risk minimization. However,
inspired by the success of GANs (Goodfellow et al., 2014). , ML practitioners have developed more
complicated min-max and adversarial optimization formulations (Yu et al., 2021; Kuhn et al., 2019;
Shaﬁeezadeh-Abadeh et al., 2015; Sinha et al., 2018; Lin et al., 2020; Namkoong & Duchi, 2016;
Huang et al., 2017; Wadsworth et al., 2018; Zhang et al., 2018; Edwards & Storkey, 2015; Celis
& Keswani, 2019). Solving these multi-player games leads to issues not seen when minimizing a
single-player loss function. The competitive nature of a game leads to rotational dynamics that can
cause intuitive gradient-based methods to fail to converge (Gidel et al., 2019; Daskalakis et al., 2018;
Hsieh et al., 2020)."
INTRODUCTION,0.004489337822671156,"A mathematical framework underlying both convex optimization and saddle-point problems is the
monotone inclusion problem; see Ryu & Boyd (2016) for an introduction. Methods developed
for monotone inclusions will converge for convex-concave, games as they are explicitly designed
to handle such problems’ governing dynamics. In recent years, monotone inclusion methods and
theory have started to receive attention in the ML community (Diakonikolas, 2020; Liu et al., 2021;
Ryu et al., 2020; Pathak & Wainwright, 2020), with a focus on monotone variational inequalities,
which form a special case of monotone inclusions (Antonakopoulos et al., 2019; Gidel et al., 2019;
Daskalakis et al., 2018; Hsieh et al., 2020; Mertikopoulos et al., 2019)."
INTRODUCTION,0.005611672278338945,"The most prevalent methods for solving min-max games in ML are variants of gradient descent-ascent
(GDA). This method alternates between a gradient-descent step for the minimizing player and a
gradient-ascent step for the maximizing player. Unfortunately, GDA requires additional assumptions
to converge on convex-concave games, and it even fails for some simple 2D bilinear games (Gidel
et al., 2019, Prop. 1). While there have been several approaches to modify either GDA (Chavdarova
et al., 2021; Grnarova et al., 2021; Balduzzi et al., 2018) or the underlying game objective (Mescheder
et al., 2018; Nagarajan & Kolter, 2017; Mescheder et al., 2017) to ensure convergence, this paper
instead develops a method for solving monotone inclusions that can naturally handle game dynamics."
INTRODUCTION,0.006734006734006734,Under review as a conference paper at ICLR 2022
INTRODUCTION,0.007856341189674524,"Our approach builds upon the recently proposed projective splitting (PS) method with forward
steps (Johnstone & Eckstein, 2020b). PS is designed speciﬁcally for solving monotone inclusions,
thus does not fall prey to the convergence issues that plague GDA, at least for convex-concave games.
PS is within the general class of projective splitting methods invented by Eckstein & Svaiter (2008)
and developed further in Eckstein & Svaiter (2009); Alotaibi et al. (2014); Combettes & Eckstein
(2018); Eckstein (2017); Johnstone & Eckstein (2019; 2021; 2020a). These methods work by creating
a separating hyperplane between the current iterate and the solution and then moving closer to the
solution by projecting the current iterate onto this hyperplane (see Section 3 for an overview). Other
than being able to natively handle game dynamics, the primary advantage of PS is that it fully splits
problems involving an arbitrary number of regularizers and constraints. “Full splitting” means that the
method can handle multiple regularizers and constraints through their respective individual proximal
and projection operators, along with the smooth terms via gradients. What makes this useful is that
many of the regularizers used in ML have proximal operators that are relatively easy to compute; see
for example Parikh & Boyd (2013)."
INTRODUCTION,0.008978675645342313,"Despite these advantages, the preexisting PS framework has a signiﬁcant drawback: it requires
deterministic gradient oracles. This feature makes it impractical for application to large datasets for
which stochastic oracles may be the only feasible option."
INTRODUCTION,0.010101010101010102,"Contributions
The primary contribution of this work is a new projective splitting algorithm that
allows for a stochastic gradient oracle. We call the method stochastic projective splitting (SPS). Our
method “fully splits” the monotone inclusion problem"
INTRODUCTION,0.01122334455667789,"Find z ∈Rd s.t. 0 ∈Pn
i=1 Ai(z) + B(z),
(1)"
INTRODUCTION,0.012345679012345678,"where B is monotone and L-Lipschitz and each Ai is maximal monotone and typically set valued,
usually arising from a constraint or a nonsmooth regularizer in the underlying optimization problem
or game; see for example Ryu & Boyd (2016) for deﬁnitions. For some example ML applications
of (1), see Section 2 and Appendix A. Here, an algorithm that “fully splits” (1) means one whose
computational steps each involve only the individual operators A1, . . . , An, B. Ours is the ﬁrst
method that can accomplish full splitting without a product-space reformulation that recasts (1) as a
two-operator problem on a higher-dimensional space, a tactic whose disadvantages are discussed in
Appendix F.7. Our method interrogates the Lipschitz operator B through a stochastic oracle. Previous
methods splitting (1) have either required a deterministic oracle for B, or have made far more
restrictive assumptions on the noise or the operators (Briceño-Arias & Combettes, 2011; Combettes &
Pesquet, 2012; Malitsky & Tam, 2020; Bot et al., 2019; Van Dung & Vu, 2021) than we will require
below. However, the stochastic methods of Alacaoglu et al. (2021) and Böhm et al. (2020), when
combined with a product-space reformulation, can solve (1) when all the Ai are subdifferentials of
convex functions; see Section 6."
INTRODUCTION,0.013468013468013467,"When moving away from a deterministic gradient oracle in projective splitting, a key difﬁculty is that
the generated hyperplanes do not guarantee separation between the solution and the current point. We
solve this issue by relaxing the projection: we only update each iterate in the direction of the noisy
projection and scale its movement by a decreasing stepsize that allows for control of the stochastic
error. Using the framework of stochastic quasi-Fejér monotonicity (Combettes & Pesquet, 2015),
we prove almost-sure convergence of the ﬁnal iterate and do not require averaging of the iterates
(Theorem 1, Section 5). We also provide a non-asymptotic convergence rate for the approximation
residual (Theorem 2, Section 5)."
INTRODUCTION,0.014590347923681257,"A special case of SPS is the recently-developed Double Stepsize Extragradient Method (DSEG) (Hsieh
et al., 2020). When n = 0 and therefore only B is present in (1), DSEG and SPS coincide. Thus, our
method extends DSEG to allow for regularizers and constraints. Our analysis also provides a new
interpretation for DSEG as a special case of projective splitting. Our nonasymptotic convergence rate
for SPS also applies to DSEG under no additional assumptions. By contrast, the original convergence
rate analysis for DSEG requires either strong monotonicity or an error bound."
INTRODUCTION,0.015712682379349047,"We close with numerical experiments on a distributionally robust sparse logistic regression problem.
This is a nonsmooth convex-concave min-max problem which can be converted to (1) with n = 2
set-valued operators. On this problems class, SPS compares well to the possible alternative splitting
methods."
INTRODUCTION,0.016835016835016835,Under review as a conference paper at ICLR 2022
INTRODUCTION,0.017957351290684626,"Non-monotone problems
The work of Hsieh et al. (2020) included a local convergence analysis
for DSEG applied to locally monotone problems. For min-max problems, if the objective is locally
convex-concave at a solution and DSEG is initialized in close proximity, then for small enough
stepsizes it converges to the solution with high probability. It is possible to extend this result to SPS,
along with our convergence rate analysis. This result is beyond the scope of this work, but Appendix
J provides a proof sketch."
BACKGROUND ON MONOTONE INCLUSIONS,0.019079685746352413,"2
BACKGROUND ON MONOTONE INCLUSIONS"
BACKGROUND ON MONOTONE INCLUSIONS,0.020202020202020204,"Since they are so important to SPS, this section provides some background material regarding mono-
tone inclusions, along with their connections to convex optimization, games, and ML. Appendix G
discusses their connections to variational inequalities. For a more thorough treatment, we refer
to Bauschke & Combettes (2017). See Appendix A for a longer discussion of the applications of
monotone inclusions to ML along with several examples."
BACKGROUND ON MONOTONE INCLUSIONS,0.02132435465768799,"Fundamentals
Let f : Rd →R ∪{∞} be closed, convex, and proper (CCP). Recall that its
subdifferential ∂f is given by ∂f(x) .= {g : f(y) ≥f(x) + g⊤(y −x)}. The map ∂f has the
property
u ∈∂f(x), v ∈∂f(y) =⇒(u −v)
⊤(x −y) ≥0,
and any point-to-set map having this property is called a monotone operator. A monotone operator
T is called maximal if no additional points can be included in the image T(x) of any x ∈Rd
without violating the above property (Bauschke & Combettes, 2017, Def. 20.20). Subgradient maps
of CCP functions are maximal (Bauschke & Combettes, 2017, Thm. 20.25). A minimizer of f is
any x∗such that 0 ∈∂f(x∗). This is perhaps the simplest example of a monotone inclusion, the
problem of ﬁnding x such that 0 ∈T(x), where T is a monotone operator. If f is smooth, then
∂f(x) = {∇f(x)} for all x, and the monotone inclusion 0 ∈∂f(x) is equivalent to the ﬁrst-order
optimality condition 0 = ∇f(x)."
BACKGROUND ON MONOTONE INCLUSIONS,0.02244668911335578,"Under certain regularity conditions (Bauschke & Combettes, 2017, Cor. 16.5), minimizing a sum of
CCP functions f1, . . . , fn is equivalent to solving the monotone inclusion formed from the sum of
their subdifferentials:"
BACKGROUND ON MONOTONE INCLUSIONS,0.02356902356902357,"x∗∈arg min
x∈Rd n
X"
BACKGROUND ON MONOTONE INCLUSIONS,0.024691358024691357,"i=1
fi(x) ⇐⇒0 ∈ n
X"
BACKGROUND ON MONOTONE INCLUSIONS,0.025813692480359147,"i=1
∂fi(x∗).
(2)"
BACKGROUND ON MONOTONE INCLUSIONS,0.026936026936026935,"As throughout this paper for all set addition operations, the summation on the right-hand side of (2)
is the Minkowski sum Pn
i=1 Si = {Pn
i=1 si | si ∈Si ∀i ∈1..n}. For a convex set X, a constraint
x ∈C for some convex set C may be imposed by setting one of the fi to be the indicator function ιC,
deﬁned by ιC(x) = 0 for x ∈C and ιC(x) = +∞for x ̸∈C. Indicator functions of closed convex
sets are CCP (Bauschke & Combettes, 2017, Ex. 1.25), and the subgradient map of ιC is also referred
to as the normal cone map NC of C (Bauschke & Combettes, 2017, Def. 6.37). Multiple constraints
may be imposed by including multiple indicator functions in (2)."
BACKGROUND ON MONOTONE INCLUSIONS,0.028058361391694726,"ML applications
The form (2) can be used to model ML problems with multiple constraints and/or
nonsmooth regularizers, including sparse and overlapping group lasso (Jacob et al., 2009), sparse and
low-rank matrix estimation problems (Richard et al., 2012), and rare feature selection (Yan & Bien,
2020); see Pedregosa & Gidel (2018) for an overview."
BACKGROUND ON MONOTONE INCLUSIONS,0.029180695847362513,"Games
Consider a two-player noncooperative game in which each player tries to selﬁshly minimize
its own loss, with each loss depending on the actions of both players. Typically, the goal is to ﬁnd a
Nash equilibrium, in which neither player can improve its loss by changing strategy:
x∗∈arg min
x∈Θ
F(x, y∗)
and
y∗∈arg min
y∈Ω
G(x∗, y).
(3)"
BACKGROUND ON MONOTONE INCLUSIONS,0.030303030303030304,"Assuming that the admissible strategy sets Θ ⊆Rdx and Ω⊆Rdy are closed and convex and that
F and G are differentiable, then writing the ﬁrst-order necessary conditions for each optimization
problem in (3) yields"
BACKGROUND ON MONOTONE INCLUSIONS,0.031425364758698095,"0 ∈

∇xF(x∗, y∗)
∇yG(x∗, y∗)"
BACKGROUND ON MONOTONE INCLUSIONS,0.03254769921436588,"
+
 
NΘ(x∗) × NΩ(y∗)

.
(4)"
BACKGROUND ON MONOTONE INCLUSIONS,0.03367003367003367,Under review as a conference paper at ICLR 2022
BACKGROUND ON MONOTONE INCLUSIONS,0.03479236812570146,"If G = −F, then (3) is a min-max game. If F is also convex in x and concave in y, then B : (x, y) 7→
(∇xF(x, y), −∇yF(x, y))⊤is monotone1 on Rdx+dy (Rockafellar, 1970). In many applications, B
is also Lipschitz continuous. In this situation, (4) is a monotone inclusion involving two operators
B and NΘ×Ω, with B being Lipschitz. Using the simultaneous version of GDA on (3) is equivalent
to applying the forward-backward method (FB) (Bauschke & Combettes, 2017, Thm. 26.14) to (4).
However, convergence of FB requires that the operator B be cocoercive (Bauschke & Combettes,
2017, Def. 4.10), and not merely Lipschitz (Bauschke & Combettes, 2017, Thm. 26.14). Thus,
simultaneous GDA fails to converge for (3) without additional assumptions; see Gidel et al. (2019,
Prop. 1) for a simple counterexample."
BACKGROUND ON MONOTONE INCLUSIONS,0.03591470258136925,"Regularizers and further constraints may be imposed by adding more operators to (4). For example,
if one wished to apply a (nonsmooth) convex regularizer r : Rdx →R ∪{+∞} to the x variables
and a similar regularizer d : Rdy →R ∪{+∞} to the y variables, one would add the operator
A2 : (x, y) 7→∂r(x) × ∂d(y) to the right-hand side of (4)."
BACKGROUND ON MONOTONE INCLUSIONS,0.037037037037037035,"ML applications of games
Distributionally robust supervised learning (DRSL) is an emerging
framework for improving the stability and reliability of ML models in the face of distributional
shifts (Yu et al., 2021; Kuhn et al., 2019; Shaﬁeezadeh-Abadeh et al., 2015; Sinha et al., 2018; Lin
et al., 2020; Namkoong & Duchi, 2016). Common approaches to DRSL formulate the problem as
a min-max game between a learner selecting the model parameters and an adversary selecting a
worst-case distribution subject to some ambiguity set around the observed empirical distribution.
This min-max problem is often further reduced to either a ﬁnite-dimensional saddlepoint problem or
a convex optimization problem."
BACKGROUND ON MONOTONE INCLUSIONS,0.038159371492704826,"DRSL is a source of games with multiple constraints/regularizers. One such formulation, based on
Yu et al. (2021), is discussed in the experiments below. The work in Namkoong & Duchi (2016) uses
an ambiguity set based on f-divergences, while Sinha et al. (2018) introduce a Lagrangian relaxation
of the Wasserstein ball. When applied to models utilizing multiple regularizers (Jacob et al., 2009;
Richard et al., 2012; Yan & Bien, 2020), both of these approaches lead to min-max problems with
multiple regularizers."
BACKGROUND ON MONOTONE INCLUSIONS,0.03928170594837262,"Other applications of games in ML, although typically nonconvex, include generative adversarial net-
works (GANs) (Goodfellow et al., 2014; Arjovsky et al., 2017; Loizou et al., 2020; 2021; Mishchenko
et al., 2020), fair classiﬁcation (Wadsworth et al., 2018; Zhang et al., 2018; Edwards & Storkey, 2015;
Celis & Keswani, 2019), and adversarial privacy (Huang et al., 2017)."
BACKGROUND ON MONOTONE INCLUSIONS,0.04040404040404041,"Resolvents, proximal operators, and projections
A fundamental computational primitive for
solving monotone inclusions is the resolvent. The resolvent of a monotone operator A is deﬁned to
be JA .= (I + A)−1, where I is the identity operator and the inverse of any operator T is simply
T −1 : x 7→{y : Ty ∋x}. If A is maximal monotone, then for any ρ > 0, JρA is single valued,
nonexpansive, and has domain equal to Rd (Bauschke & Combettes, 2017, Thm. 21.1 and Prop.
23.8). Resolvents generalize proximal operators of convex functions: the proximal operator of a CCP
function f is"
BACKGROUND ON MONOTONE INCLUSIONS,0.04152637485970819,"proxρf(t) .= arg min
x∈Rd"
BACKGROUND ON MONOTONE INCLUSIONS,0.04264870931537598,"
ρf(x) + (1/2)∥x −t∥2	
."
BACKGROUND ON MONOTONE INCLUSIONS,0.04377104377104377,"It is easily proved that proxρf = Jρ∂f. Like proximal operators, resolvents generalize projection
onto convex sets: if f = ιC, then JρNC = proxρf = projC for any ρ > 0. In many ML applications,
proximal operators, and hence resolvents, are relatively straightforward to compute. For examples,
see Parikh & Boyd (2013, Sec. 6)."
BACKGROUND ON MONOTONE INCLUSIONS,0.04489337822671156,"Operator splitting methods
Operator splitting methods attempt to solve monotone inclusions such
as (1) by a sequence of operations that each involve only one of the operators A1, . . . , An, B. Such
methods are often presented in the context of convex optimization problems like (2), but typically
apply more generally to monotone inclusions such as (1). In the speciﬁc context of (1), each iteration
of such a method ideally handles each Ai via its resolvent and the Lipschitz operator B by explicit
(not stochastic) evaluation. This is a feasible approach if the original problem can be decomposed in"
BACKGROUND ON MONOTONE INCLUSIONS,0.04601571268237935,"1Sufﬁcient conditions for the monotonicity of (4) in the case where G ̸= −F are discussed in e.g. Scutari
et al. (2014); Briceño-Arias & Combettes (2013)."
BACKGROUND ON MONOTONE INCLUSIONS,0.04713804713804714,Under review as a conference paper at ICLR 2022
BACKGROUND ON MONOTONE INCLUSIONS,0.04826038159371493,"such a way that the resolvents of each Ai are relatively inexpensive to compute, and full evaluations
of B are possible. Although not discussed here, more general formulations in which matrices couple
the arguments of the operators can broaden the applicability of operator splitting methods."
THE PROJECTIVE SPLITTING FRAMEWORK,0.04938271604938271,"3
THE PROJECTIVE SPLITTING FRAMEWORK"
THE PROJECTIVE SPLITTING FRAMEWORK,0.050505050505050504,"Before introducing our proposed method, we give a brief introduction to the projective splitting class
of methods."
THE PROJECTIVE SPLITTING FRAMEWORK,0.051627384960718295,"The extended solution set
Projective splitting is a primal-dual framework and operates in an
extended space of primal and dual variables. Rather than directly ﬁnding a solution to (1), we ﬁnd a
point in the extended solution set (or Kuhn-Tucker set)"
THE PROJECTIVE SPLITTING FRAMEWORK,0.052749719416386086,"S .=
n
(z, w1, . . . , wn+1)
 wi ∈Ai(z) ∀i ∈1..n, wn+1 = B(z), Pn+1
i=1 wi = 0
o
.
(5)"
THE PROJECTIVE SPLITTING FRAMEWORK,0.05387205387205387,"Given p∗= (z∗, w∗
1 . . . , w∗
n+1) ∈S, it is straightforward to see that z∗solves (1). Conversely, given
a solution z∗to (1), there must exist w∗
1, . . . , w∗
n+1 such that (z∗, w∗
1, . . . , w∗
n+1) ∈S. Suppose
p∗= (z∗, w∗
1 . . . , w∗
n+1) ∈S. Since z∗solves (1), z∗is typically referred to as a primal solution.
The vectors w∗
1, . . . , w∗
n+1 solve a dual inclusion not described here, and are therefore called a dual
solution. It can be shown that S is closed and convex; see for example Johnstone & Eckstein (2020b).
We will assume throughout that a solution to (1) exists, therefore the set S is nonempty."
THE PROJECTIVE SPLITTING FRAMEWORK,0.05499438832772166,"Separator-projection framework
Projective splitting methods are instances of the general
separator-projection algorithmic framework for locating a member of a closed convex set S within
a linear space P. Each iteration k of algorithms drawn from this framework operates by ﬁnding a
set Hk that separates the current iterate pk ∈P from S, meaning that S is entirely in the set and
pk typically is not. One then attempts to “move closer"" to S by projecting the pk onto Hk. In the
particular case of projective splitting applied to the problem (1) using (5), we select the space P to be"
THE PROJECTIVE SPLITTING FRAMEWORK,0.05611672278338945,"P .=
n
(z, w1, . . . , wn+1) ∈R(n+2)d  Pn+1
i=1 wi = 0
o
,
(6)"
THE PROJECTIVE SPLITTING FRAMEWORK,0.05723905723905724,"and each separating set Hk to be the half space {p ∈P | ϕk(p) ≤0} generated by an afﬁne function
ϕk : P →R. The general intention is to construct ϕk such that ϕk(pk) > 0, but ϕk(p∗) ≤0 for all
p∗∈S. The construction employed for ϕk in the case of (1) and (5) is of the form"
THE PROJECTIVE SPLITTING FRAMEWORK,0.058361391694725026,"ϕk(z, w1, . . . , wn+1) .= Pn+1
i=1 ⟨z −xk
i , yk
i −wi⟩
(7)"
THE PROJECTIVE SPLITTING FRAMEWORK,0.05948372615039282,"for some points (xk
i , yk
i ) ∈R2d, i ∈1..(n + 1), that must be carefully chosen (see below). Any
function of the form (7) can be shown to be afﬁne when restricted to P. As mentioned above, the
standard separator-projection algorithm obtains its next iterate pk+1 by projecting pk onto Hk. This
calculation involves the usual projection step for a half space, namely"
THE PROJECTIVE SPLITTING FRAMEWORK,0.06060606060606061,"pk+1 = pk −αk∇ϕk,
where
αk = ϕk(pk)/∥∇ϕk∥2,
(8)"
THE PROJECTIVE SPLITTING FRAMEWORK,0.06172839506172839,"and the gradient ∇ϕk is computed relative to P, thus resulting in pk+1 ∈P, i.e.
∇ϕk =
Pn+1
i=1 yk
i , xk
1 −¯xk, . . . , xn+1 −¯xk
where ¯xk =
1
n+1
Pn+1
i=1 xk
i ."
PROPOSED METHOD,0.06285072951739619,"4
PROPOSED METHOD"
PROPOSED METHOD,0.06397306397306397,"The proposed method is given in Algorithm 1 and called Stochastic Projective Splitting (SPS). Unlike
prior versions of projective splitting, SPS does not employ the stepsize αk of (8) that places the next
iterate exactly on the hyperplane given by ϕk(p) = 0. Instead, it simply moves in the direction −∇ϕk
with a pre-deﬁned stepsize {αk}. This fundamental change is required to deal with the stochastic
noise on lines 6 and 8. This noise could lead to the usual choice of αk deﬁned in (8) being unstable
and difﬁcult to analyze. In order to guarantee convergence, the parameters αk and ρk must be chosen
to satisfy certain conditions given below. Note that the gradient is calculated with respect to the
subspace P deﬁned in (6); since the algorithm is initialized within P, it remains in P, within which
ϕk is afﬁne. Collectively, the updates on lines 9-10 are equivalent to pk+1 = pk −αk∇ϕk, where
pk = (zk, wk
1, . . . , wk
n+1)."
PROPOSED METHOD,0.06509539842873176,Under review as a conference paper at ICLR 2022
PROPOSED METHOD,0.06621773288439955,"Note that SPS does not explicitly evaluate ϕk, which is only used in the analysis, but it does keep
track of (xk
i , yk
i ) for i ∈1..(n + 1). The algorithm’s memory requirements scale linearly with the
number of nonsmooth operators n in the inclusion (1), with the simplest implementation storing
(3n+5)d working-vector elements. This requirement can be reduced to (n+7)d through a technique
discussed in Appendix H. In most applications, n will be small, for example 2 or 3."
PROPOSED METHOD,0.06734006734006734,"Updating (xk
i , yk
i )
The variables (xk
i , yk
i ) are updated on lines 3-8 of Algorithm 1, in which ek"
PROPOSED METHOD,0.06846240179573512,"and ϵk are Rd-valued random variables deﬁned on a probability space (Ω, F, P). For B we use a
new, noisy version of the two-forward-step procedure from Johnstone & Eckstein (2020b). For each
Ai, i ∈1..n, we use the same resolvent step used in previous projective splitting papers, originating
with (Eckstein & Svaiter, 2008). In the case ϵk = ek = 0, the selection of the (xk
i , yk
i ) is identical to
that proposed by Johnstone & Eckstein (2020b), resulting in the hyperplane {p : ϕk(p) = 0} strictly
separating pk from S."
PROPOSED METHOD,0.06958473625140292,"SPS achieves full splitting of (1): each Ai is processed separately using a resolvent and the Lipschitz
term B is processed via a stochastic gradient oracle. When the Ai arise from regularizers or
constraints, as discussed in Section 2, their resolvents can be readily computed so long as their
respective proximal/projection operators have a convenient form."
PROPOSED METHOD,0.0707070707070707,"Noise assumptions
Let Fk .= σ(p1, . . . , pk) and Ek .= σ(ϵk). The stochastic estimators for the
gradients, rk and yk
n+1, are assumed to be unbiased, that is, the noise terms have mean 0 conditioned
on the past:"
PROPOSED METHOD,0.0718294051627385,"E[ϵk|Fk] = 0,
E[ek|Fk] = 0
a.s.
(9)"
PROPOSED METHOD,0.07295173961840629,We impose the following mild assumptions on the variance of the noise:
PROPOSED METHOD,0.07407407407407407,"E

∥ϵk∥2|Fk

≤N1 + N2∥B(zk)∥2
a.s.
(10)"
PROPOSED METHOD,0.07519640852974187,"E

∥ek∥2|Fk, Ek

≤N3 + N4∥B(xk
n+1)∥2
a.s.,
(11)"
PROPOSED METHOD,0.07631874298540965,"where 0 ≤N1, N2, N3, N4 < ∞. We do not require ek and ϵk to be independent of one another."
PROPOSED METHOD,0.07744107744107744,"Stepsize choices
The stepsizes ρk and αk are assumed to be deterministic. A constant stepsize
choice which attains a non-asymptotic convergence rate will be considered in the next section
(Theorem 2). The stepsize conditions we will impose to guarantee almost-sure convergence (Theorem
1) are
P∞
k=1 αkρk = ∞,
P∞
k=1 α2
k < ∞,
P∞
k=1 αkρ2
k < ∞, and ρk ≤ρ < 1/L.
(12)"
PROPOSED METHOD,0.07856341189674523,"For example, in the case L = 1, a particular choice which satisﬁes these constraints is"
PROPOSED METHOD,0.07968574635241302,"αk = k−0.5−p for 0 < p < 0.5, and ρk = k−0.5+t for p ≤t < 0.5p + 0.25."
PROPOSED METHOD,0.08080808080808081,"For simplicity, the stepsizes τ used for the resolvent updates in lines 3-5 are ﬁxed, but they could be
allowed to vary with both i and k so long as they have ﬁnite positive lower and upper bounds."
PROPOSED METHOD,0.0819304152637486,Algorithm 1: Stochastic Projective Splitting (SPS)
PROPOSED METHOD,0.08305274971941638,"Input :p1 = (z1, w1
1, . . . , w1
n+1) s.t. Pn+1
i=1 w1
i = 0, {αk, ρk}∞
k=1, τ > 0"
PROPOSED METHOD,0.08417508417508418,"1 for k = 1, 2, . . . do"
PROPOSED METHOD,0.08529741863075196,"2
for i ∈1..n do"
TK,0.08641975308641975,"3
tk
i = zk + τwk
i"
XK,0.08754208754208755,"4
xk
i = JτAi(tk
i )"
YK,0.08866442199775533,"5
yk
i = τ −1(tk
i −xk
i )"
YK,0.08978675645342311,"6
rk = B(zk) + ϵk
// ϵk is unknown noise term"
XK,0.09090909090909091,"7
xk
n+1 = zk −ρk(rk −wk
n+1)"
YK,0.0920314253647587,"8
yk
n+1 = B(xk
n+1) + ek
// ek is unknown noise term"
YK,0.0931537598204265,"9
zk+1 = zk −αk
Pn+1
i=1 yk
i"
YK,0.09427609427609428,"10
wk+1
i
= wk
i −αk(xk
i −
1
n+1
Pn+1
i=1 xk
i )
i ∈1..(n + 1)"
YK,0.09539842873176206,Under review as a conference paper at ICLR 2022
MAIN THEORETICAL RESULTS,0.09652076318742986,"5
MAIN THEORETICAL RESULTS"
MAIN THEORETICAL RESULTS,0.09764309764309764,"Theorem 1. Suppose A1, . . . , An are maximal monotone, B is L-Lipschitz and monotone, and a
solution to (1) exists. For Algorithm 1, suppose (9)-(12) hold. Then with probability one it holds that
zk →z∗, where z∗solves (1). Further, with probability one, xk
i →z∗for i = 1, . . . , n."
MAIN THEORETICAL RESULTS,0.09876543209876543,"Proof sketch
Theorem 1 is proved in Appendix C, but we provide a brief sketch here. The proof
begins by deriving a simple recursion inspired by the analysis of SGD (Robbins & Monro, 1951).
Since pk+1 = pk −αk∇ϕk, a step of projective splitting can be viewed as GD applied to the afﬁne
hyperplane generator function ϕk. Thus, for any p∗∈P,
∥pk+1 −p∗∥2 = ∥pk −p∗∥2 −2αk⟨∇ϕk, pk −p∗⟩+ α2
k∥∇ϕk∥2"
MAIN THEORETICAL RESULTS,0.09988776655443322,"= ∥pk −p∗∥2 −2αk(ϕk(pk) −ϕk(p∗)) + α2
k∥∇ϕk∥2,
(13)
where in the second equation we have used that ϕk(p) is afﬁne on P. The basic strategy is to show
that, for any p∗∈S,
E[∥∇ϕk∥2|Fk] ≤C1∥pk −p∗∥2 + C2
a.s.
for some C1, C2 > 0. This condition allows one to establish stochastic quasi-Fejér monotonicity
(SQFM) (Combettes & Pesquet, 2015, Proposition 2.3) of the iterates to S. One consequence of
SQFM is that with probability one there exists a subsequence vk such that ϕvk(pvk) −ϕvk(p∗)
converges to 0. Furthermore, roughly speaking, we show that ϕk(pk) −ϕk(p∗) provides an upper
bound on the following “approximation residual"" for SPS:
Gk .= Pn
i=1 ∥yk
i −wk
i ∥2 + Pn
i=1 ∥zk −xk
i ∥2 + ∥B(zk) −wk
n+1∥2.
(14)
Gk provides an approximation error for SPS, as formalized in the following lemma:
Lemma 1. For SPS, pk = (zk, wk
1, . . . , wk
n+1) ∈S if and only if Gk = 0.
Since yk
i ∈Ai(xk
i ) for i ∈1..n, having Gk = 0 implies that zk = xk
i , wk
i = yk
i , and thus
wk
i ∈Ai(zk) for i ∈1..n. Since wk
n+1 = B(zk) and Pn+1
i=1 wk
i = 0, it follows that zk solves (1).
The reverse direction is proved in Appendix D."
MAIN THEORETICAL RESULTS,0.10101010101010101,"The quantity Gk generalizes the role played by the norm of the gradient in algorithms for smooth
optimization. In particular, in the special case where n = 0 and B(z) = ∇f(z) for some smooth
convex function f, one has Gk = ∥∇f(zk)∥2."
MAIN THEORETICAL RESULTS,0.10213243546576879,"Combining the properties of Gk with other results following from SQFM (such as boundedness) will
allow us to derive almost-sure convergence of the iterates to a solution of (1)."
MAIN THEORETICAL RESULTS,0.10325476992143659,"Convergence rate
We can also establish non-asymptotic convergence rates for the approximation
residual Gk:
Theorem 2. Fix the total iterations K ≥1 of Algorithm 1 and set"
MAIN THEORETICAL RESULTS,0.10437710437710437,"∀k = 1, . . . , K : ρk = ρ .= min
n
K−1/4, 1/2L
o
and
αk = Cfρ2
(15)"
MAIN THEORETICAL RESULTS,0.10549943883277217,for some Cf > 0. Suppose (9)-(11) hold. Then
MAIN THEORETICAL RESULTS,0.10662177328843996,"(1/K)PK
j=1 E[Gj] = O(K−1/4)
where the constants are given (along with the proof) in Appendix E."
MAIN THEORETICAL RESULTS,0.10774410774410774,"Theorem 2 implies that if we pick an iterate J uniformly at random from 1..K, then the expected
value of GJ is O(K−1/4). As far as we know, this is the ﬁrst convergence rate for a stochastic full-
splitting method solving (1) in the general discontinuous (i.e. set-valued) monotone inclusion case,
and it is not clear whether it can be improved, either by a better analysis or a better method. Faster
rates are certainly possible for deterministic methods under various continuity assumptions; Tseng’s
method obtains O(K−1) rate (Monteiro & Svaiter, 2010) and the accelerated Halpern iteration under
Lipschitz continuity obtains O(K−2) rate (Diakonikolas, 2020). While our rate may seem slow, it
is worth remembering that (1) features n discontinuous operators Ai, so we expect rates at least as
slow as nonsmooth convex optimization, but perhaps worse because (1) is far more general than
convex optimization. For a different error metric, the restricted gap function, in the special case of
variational inequalities, faster rates have been established in Juditsky et al. (2011) and Böhm et al.
(2020). However, it is unclear how to relate the restricted gap function to Gk, so these rates may not
be directly comparable to Theorem 2."
MAIN THEORETICAL RESULTS,0.10886644219977554,Under review as a conference paper at ICLR 2022
RELATED WORK,0.10998877665544332,"6
RELATED WORK"
RELATED WORK,0.1111111111111111,"Arguably the three most popular classes of operator splitting algorithms are forward-backward
splitting (FB) (Combettes & Pesquet, 2011), Douglas-Rachford splitting (DR) (Lions & Mercier,
1979), and Tseng’s method (Tseng, 2000). The extragradient method (EG) is similar to Tseng’s
method, but has more projection steps per iteration and only applies to variational inequalities
(Korpelevich, 1977; Nemirovski, 2004; Li et al., 2021). The popular Alternating Direction Method
of Multipliers (ADMM), in its standard form, is a dual application of DR (Gabay, 1983). The
three-operator splitting method (Davis & Yin, 2017) can only be applied to (1) if B is cocoercive
rather than merely Lipchitz, and thus its usefulness is mostly limited to optimization applications and
not games. FB, DR, and Tseng’s method apply to monotone inclusions involving two operators, with
varying assumptions on one of the operators. It is possible to derive splitting methods for the more
complicated inclusion (1), involving more than two operators, by applying an appropriate 2-operator
splitting method such as Tseng’s method to a product-space reformulation (PSR) (Briceño-Arias &
Combettes, 2011; Combettes & Pesquet, 2012) (for more on PSR, see Appendix F). The recently
developed forward-reﬂected-backward (FRB) method (Malitsky & Tam, 2020) can be used in the
same way. However, there are several disadvantages to using a PSR, as discussed in Appendix F.7."
RELATED WORK,0.1122334455667789,"By using a PSR, the stochastic methods of Alacaoglu et al. (2021) and Böhm et al. (2020) can be
applied to (1) in the case that each Ai is a subdifferential. Both of these methods are analyzed in terms
of the restricted gap function. This merit function has a drawback compared with our approximation
residual in that it requires one to ﬁnd a bound for the iterates. However, Alacaoglu et al. (2021) and
Böhm et al. (2020) do not provide such a bound, meaning that their convergence rate results are
somewhat incomplete. We discuss this issue in Appendix G."
RELATED WORK,0.11335578002244669,"Theoretical convergence of the method of Böhm et al. (2020) requires the use of averaging, since
the ﬁnal iterate does not converge for certain problems (Hsieh et al., 2020). Empirically, averaging
tends to be slow and to destroy regularizer-induced structural properties such as sparsity or low
matrix rank, so its utility is largely theoretical and it is usually avoided in practice. Furthermore,
averaging loses even its theoretical beneﬁts for nonconvex problems, so its use in such cases is rarer
still. Another drawback of the analysis of Böhm et al. (2020) is that, unlike in SPS, the resolvent
(proximal) stepsizes also need to vanish."
RELATED WORK,0.11447811447811448,"The method of Alacaoglu et al. (2021) applies variance reduction techniques to FRB. It only applies
to ﬁnite-sum problems and requires the periodic computation of a full batch gradient, making it
somewhat less ﬂexible and scalable than our method. On the other hand, it has an accelerated ergodic
rate for the restricted gap function in the variational inequality setting. We compare the empirical
performance of SPS with Alacaoglu et al. (2021), Böhm et al. (2020), and several deterministic
methods using PSR in the numerical experiments described in Section 7."
RELATED WORK,0.11560044893378227,Additional related work is discussed in Appendix B.
EXPERIMENTS,0.11672278338945005,"7
EXPERIMENTS"
EXPERIMENTS,0.11784511784511785,"We now present some numerical results on distributionally robust supervised learning (DRSL)
problems. We follow the approach of Yu et al. (2021), which introduced a min-max formulation of
Wasserstein DRSL. While other approaches reduce the problem to convex optimization, Yu et al.
(2021) reduce it to a ﬁnite-dimensional min-max problem amenable to the use of stochastic methods
on large datasets. However, unlike our proposed SPS method, the variance-reduced extragradient
method that Yu et al. (2021) propose cannot handle multiple nonsmooth regularizers or constraints on
the model parameters. Consequently, we consider distributionally robust sparse logistic regression
(DRSLR), a problem class equivalent to that considered in Yu et al. (2021), but with an added ℓ1
regularizer, a standard tool to induce sparsity. See the Appendix I for the full problem deﬁnition."
EXPERIMENTS,0.11896745230078563,"We compared our SPS method to several methods for solving DRSLR for a collection of real datasets
from the LIBSVM repository (Chang & Lin, 2011). We implemented SPS with αk = Cdk−0.51 and
ρk = Cdk−0.25 and called it SPS-decay. We also implement SPS with the ﬁxed stepsize given in (15)
and called it SPS-ﬁxed. We compared the method to deterministic projective splitting (Johnstone &
Eckstein, 2020b) and the following methods based on PSR: Tseng’s method (Tseng, 2000; Combettes
& Pesquet, 2012), the forward-reﬂected-backward (FRB) method (Malitsky & Tam, 2020), the"
EXPERIMENTS,0.12008978675645342,Under review as a conference paper at ICLR 2022
EXPERIMENTS,0.12121212121212122,"Figure 1: Approximation residual versus running time for three LIBSVM benchmark datasets,
with the markers at 10-iteration intervals. Left: epsilon, middle: SUSY, right: real-sim. For the
stochastic algorithms (SPS, S-Tseng, and FRB-VR), we plot the median results over 10 trials, with
unit standard deviation horizontal error bars for the running time and the vertical error bars displaying
the min-to-max range of the approximation residual. The code is provided in the supplementary
material."
EXPERIMENTS,0.122334455667789,"stochastic Tseng (S-Tseng) method of Böhm et al. (2020), and the variance-reduced stochastic FRB
method (Alacaoglu et al., 2021), abbreviated FRB-VR. The S-Tseng and FRB-VR algorithms appear
to be the only stochastic splitting methods other than SPS applicable to the tested problem class."
EXPERIMENTS,0.12345679012345678,"Figure 1 show results for three LIBSVM standard datasets: epsilon2 (m = 4 · 105, d = 2000),
SUSY (Baldi et al., 2014; Dua & Graff, 2017) (m = 2 · 106, d = 18), and real-sim3 (m = 72,309,
d = 20,958)."
EXPERIMENTS,0.12457912457912458,"To measure the progress of the algorithms, we used the “approximation residual” Rk deﬁned in
Appendix F. As with Gk, having Rk = 0 implies that zk solves (1). We use Rk instead of Gk
because it is also possible to compute essentially the same measure of convergence from the iterates
of the other tested algorithms, establishing a fair comparison. Appendix F provides the details of the
derivation of the residual measure for each algorithm, explores the relationship between Rk and Gk,
and provides additional implementation details."
EXPERIMENTS,0.12570145903479238,"Figure 1 plots the approximation residual versus running time for all seven algorithms under consid-
eration. The computations were performed using Python 3.8.3 and numpy on a 2019 MacBook Pro
with a 2.4GHz 8-core Intel I9 processor and 32GB of RAM . Being a stochastic method, SPS-decay
seems to outperform the deterministic methods at obtaining a medium-accuracy solution quickly. It
also seems to outperform the stochastic PSR-based methods S-Tseng and FRB-VR."
CONCLUSIONS AND FUTURE WORK,0.12682379349046016,"8
CONCLUSIONS AND FUTURE WORK"
CONCLUSIONS AND FUTURE WORK,0.12794612794612795,"We have developed and analyzed a stochastic splitting method that can handle min-max problems
with multiple regularizers and constraints. Going forward, this development should make it possible
to incorporate regularizers and constraints into adversarial formulations trained from large datasets."
CONCLUSIONS AND FUTURE WORK,0.12906846240179573,"Recent versions of deterministic projective splitting (Combettes & Eckstein, 2018; Johnstone &
Eckstein, 2020b) allow for asynchronous and incremental operation, meaning that not all operators
need to be activated at every iteration, with some calculations proceeding with stale inputs. Such
characteristics make projective splitting well-suited to distributed implementations. Many of our SPS
results may be extended to allow for these variations, but we leave those extensions to future work."
REFERENCES,0.13019079685746351,REFERENCES
REFERENCES,0.13131313131313133,"Ahmet Alacaoglu, Yura Malitsky, and Volkan Cevher. Forward-reﬂected-backward method with
variance reduction. Computational Optimization and Applications, 2021. Available online."
REFERENCES,0.1324354657687991,"2Original data source http://largescale.ml.tu-berlin.de/instructions/
3Original data source https://people.cs.umass.edu/~mccallum/data.html"
REFERENCES,0.1335578002244669,Under review as a conference paper at ICLR 2022
REFERENCES,0.13468013468013468,"Abdullah Alotaibi, Patrick L Combettes, and Naseer Shahzad. Solving coupled composite mono-
tone inclusions by successive Fejér approximations of their Kuhn-Tucker set. SIAM Journal on
Optimization, 24(4):2076–2095, 2014."
REFERENCES,0.13580246913580246,"Kimon Antonakopoulos, Veronica Belmega, and Panayotis Mertikopoulos. An adaptive mirror-
prox method for variational inequalities with singular operators. In H. Wallach, H. Larochelle,
A. Beygelzimer, F. d'Alché-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information
Processing Systems, volume 32. Curran Associates, 2019."
REFERENCES,0.13692480359147025,"Martin Arjovsky, Soumith Chintala, and Léon Bottou. Wasserstein generative adversarial networks.
In Doina Precup and Yee Whye Teh (eds.), Proceedings of the 34th International Conference on
Machine Learning, volume 70 of Proceedings of Machine Learning Research, pp. 214–223, 06–11
Aug 2017."
REFERENCES,0.13804713804713806,"Pierre Baldi, Peter Sadowski, and Daniel Whiteson. Searching for exotic particles in high-energy
physics with deep learning. Nature communications, 5(1):1–9, 2014."
REFERENCES,0.13916947250280584,"David Balduzzi, Sebastien Racaniere, James Martens, Jakob Foerster, Karl Tuyls, and Thore Graepel.
The mechanics of n-player differentiable games. In Jennifer Dy and Andreas Krause (eds.),
Proceedings of the 35th International Conference on Machine Learning, volume 80 of Proceedings
of Machine Learning Research, pp. 354–363. PMLR, 10–15 Jul 2018."
REFERENCES,0.14029180695847362,"Heinz H Bauschke and Patrick L Combettes. Convex analysis and monotone operator theory in
Hilbert spaces. Springer, 2nd edition, 2017."
REFERENCES,0.1414141414141414,"Axel Böhm, Michael Sedlmayer, Ernö Robert Csetnek, and Radu Ioan Bo¸t. Two steps at a time —
taking GAN training in stride with Tseng’s method. arXiv preprint arXiv:2006.09033, 2020."
REFERENCES,0.1425364758698092,"Radu Ioan Bot, Panayotis Mertikopoulos, Mathias Staudigl, and Phan Tu Vuong. Forward-backward-
forward methods with variance reduction for stochastic variational inequalities. arXiv preprint
arXiv:1902.03355, 2019."
REFERENCES,0.143658810325477,"Luis M Briceño-Arias and Patrick L Combettes. A monotone+skew splitting model for composite
monotone inclusions in duality. SIAM Journal on Optimization, 21(4):1230–1250, 2011."
REFERENCES,0.1447811447811448,"Luis M Briceño-Arias and Patrick L Combettes. Monotone operator methods for Nash equilibria
in non-potential games. In Computational and Analytical Mathematics, volume 50 of Springer
Proceedings in Mathematics and Statistics, pp. 143–159. Springer, 2013."
REFERENCES,0.14590347923681257,"L Elisa Celis and Vijay Keswani. Improved adversarial learning for fair classiﬁcation. arXiv preprint
arXiv:1901.10443, 2019."
REFERENCES,0.14702581369248036,"Chih-Chung Chang and Chih-Jen Lin. LIBSVM: A library for support vector machines. ACM
Transactions on Intelligent Systems and Technology, 2:27:1–27:27, 2011. Software available at
http://www.csie.ntu.edu.tw/~cjlin/libsvm."
REFERENCES,0.14814814814814814,"Tatjana Chavdarova, Matteo Pagliardini, Sebastian U Stich, François Fleuret, and Martin Jaggi.
Taming GANs with lookahead-minmax. In International Conference on Learning Representations,
2021. URL https://openreview.net/forum?id=ZW0yXJyNmoG."
REFERENCES,0.14927048260381592,"Patrick L. Combettes and Jonathan Eckstein. Asynchronous block-iterative primal-dual decomposition
methods for monotone inclusions. Mathematical Programming, 168(1-2):645–672, 2018."
REFERENCES,0.15039281705948374,"Patrick L Combettes and Jean-Christophe Pesquet. Proximal splitting methods in signal processing.
In H.H. Bauschke, R.S.S. Burachik, P.L. Combettes, V. Elser, D.R. Luke, and H. Wolkowicz (eds.),
Fixed-Point Algorithms for Inverse Problems in Science and Engineering, pp. 185–212. Springer,
2011."
REFERENCES,0.15151515151515152,"Patrick L Combettes and Jean-Christophe Pesquet. Primal-dual splitting algorithm for solving
inclusions with mixtures of composite, Lipschitzian, and parallel-sum type monotone operators.
Set-Valued and variational analysis, 20(2):307–330, 2012."
REFERENCES,0.1526374859708193,"Patrick L Combettes and Jean-Christophe Pesquet. Stochastic quasi-Fejér block-coordinate ﬁxed
point iterations with random sweeping. SIAM Journal on Optimization, 25(2):1221–1248, 2015."
REFERENCES,0.1537598204264871,Under review as a conference paper at ICLR 2022
REFERENCES,0.15488215488215487,"Constantinos Daskalakis, Andrew Ilyas, Vasilis Syrgkanis, and Haoyang Zeng. Training GANs
with optimism. In International Conference on Learning Representations, 2018. URL https:
//openreview.net/forum?id=SJJySbbAZ."
REFERENCES,0.15600448933782268,"Damek Davis and Wotao Yin. A three-operator splitting scheme and its optimization applications.
Set-Valued and Variational Analysis, 25(4):829–858, 2017."
REFERENCES,0.15712682379349047,"Jelena Diakonikolas. Halpern iteration for near-optimal and parameter-free monotone inclusion and
strong solutions to variational inequalities. In Conference on Learning Theory, pp. 1428–1451.
PMLR, 2020."
REFERENCES,0.15824915824915825,"Dheeru Dua and Casey Graff. UCI machine learning repository, 2017. URL http://archive.
ics.uci.edu/ml."
REFERENCES,0.15937149270482603,"Jonathan Eckstein. A simpliﬁed form of block-iterative operator splitting and an asynchronous
algorithm resembling the multi-block alternating direction method of multipliers. Journal of
Optimization Theory and Applications, 173(1):155–182, 2017."
REFERENCES,0.16049382716049382,"Jonathan Eckstein and Benar Fux Svaiter. A family of projective splitting methods for the sum of
two maximal monotone operators. Mathematical Programming, 111(1):173–199, 2008."
REFERENCES,0.16161616161616163,"Jonathan Eckstein and Benar Fux Svaiter. General projective splitting methods for sums of maximal
monotone operators. SIAM Journal on Control and Optimization, 48(2):787–811, 2009."
REFERENCES,0.1627384960718294,"Harrison Edwards and Amos Storkey. Censoring representations with an adversary. arXiv preprint
arXiv:1511.05897, 2015."
REFERENCES,0.1638608305274972,"Daniel Gabay. Applications of the method of multipliers to variational inequalities. In M. Fortin and
R. Glowinski (eds.), Augmented Lagrangian Methods: Applications to the Solution of Boundary
Value Problems, chapter IX, pp. 299–340. North-Holland, Amsterdam, 1983."
REFERENCES,0.16498316498316498,"Gauthier Gidel, Hugo Berard, Gaëtan Vignoud, Pascal Vincent, and Simon Lacoste-Julien. A
variational inequality perspective on generative adversarial networks. In International Confer-
ence on Learning Representations, 2019. URL https://openreview.net/forum?id=
r1laEnA5Ym."
REFERENCES,0.16610549943883277,"Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair,
Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Z. Ghahramani, M. Welling,
C. Cortes, N. Lawrence, and K. Q. Weinberger (eds.), Advances in Neural Information Processing
Systems, volume 27. Curran Associates, 2014."
REFERENCES,0.16722783389450055,"Paulina Grnarova, Yannic Kilcher, Kﬁr Y Levy, Aurelien Lucchi, and Thomas Hofmann. Generative
minimization networks: Training GANs without competition. arXiv preprint arXiv:2103.12685,
2021."
REFERENCES,0.16835016835016836,"Patrick T Harker and Jong-Shi Pang. Finite-dimensional variational inequality and nonlinear comple-
mentarity problems: a survey of theory, algorithms and applications. Mathematical programming,
48(1):161–220, 1990."
REFERENCES,0.16947250280583614,"Yu-Guan Hsieh, Franck Iutzeler, Jérôme Malick, and Panayotis Mertikopoulos. On the convergence
of single-call stochastic extra-gradient methods. In H. Wallach, H. Larochelle, A. Beygelzimer,
F. d'Alché-Buc, E. Fox, and R. Garnett (eds.), Advances in Neural Information Processing Systems,
volume 32. Curran Associates, 2019."
REFERENCES,0.17059483726150393,"Yu-Guan Hsieh, Franck Iutzeler, Jérôme Malick, and Panayotis Mertikopoulos. Explore aggres-
sively, update conservatively: Stochastic extragradient methods with variable stepsize scaling.
In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Advances in Neural
Information Processing Systems, volume 33, pp. 16223–16234. Curran Associates, 2020."
REFERENCES,0.1717171717171717,"Chong Huang, Peter Kairouz, Xiao Chen, Lalitha Sankar, and Ram Rajagopal. Context-aware
generative adversarial privacy. Entropy, 19(12):656, 2017."
REFERENCES,0.1728395061728395,Under review as a conference paper at ICLR 2022
REFERENCES,0.1739618406285073,"Laurent Jacob, Guillaume Obozinski, and Jean-Philippe Vert. Group lasso with overlaps and graph
lasso. In Léon Bottou and Michael Littman (eds.), Proceedings of the 26th International Conference
on Machine Learning, pp. 433–440, Montreal, June 2009. Omnipress."
REFERENCES,0.1750841750841751,"Patrick R Johnstone and Jonathan Eckstein. Convergence rates for projective splitting. SIAM Journal
on Optimization, 29(3):1931–1957, 2019."
REFERENCES,0.17620650953984288,"Patrick R Johnstone and Jonathan Eckstein. Projective splitting with forward steps only requires
continuity. Optimization Letters, 14(1):229–247, 2020a."
REFERENCES,0.17732884399551066,"Patrick R Johnstone and Jonathan Eckstein. Projective splitting with forward steps. Mathematical
Programming, 2020b. Published online, to appear in print."
REFERENCES,0.17845117845117844,"Patrick R Johnstone and Jonathan Eckstein. Single-forward-step projective splitting: exploiting
cocoercivity. Computational Optimization and Applications, 78(1):125–166, 2021."
REFERENCES,0.17957351290684623,"Anatoli Juditsky, Arkadi Nemirovski, and Claire Tauvel. Solving variational inequalities with
stochastic mirror-prox algorithm. Stochastic Systems, 1(1):17–58, 2011."
REFERENCES,0.18069584736251404,"GM Korpelevich. Extragradient method for ﬁnding saddle points and other problems. Matekon, 13
(4):35–49, 1977."
REFERENCES,0.18181818181818182,"Daniel Kuhn, Peyman Mohajerin Esfahani, Viet Anh Nguyen, and Soroosh Shaﬁeezadeh-Abadeh.
Wasserstein distributionally robust optimization: Theory and applications in machine learning.
In Serguei Netessine (ed.), Operations Research & Management Science in the Age of Analytics,
Tutorials in Operations Research, pp. 130–166. INFORMS, 2019."
REFERENCES,0.1829405162738496,"Chris Junchi Li, Yaodong Yu, Nicolas Loizou, Gauthier Gidel, Yi Ma, Nicolas Le Roux, and Michael I
Jordan. On the convergence of stochastic extragradient for bilinear games with restarted iteration
averaging. arXiv preprint arXiv:2107.00464, 2021."
REFERENCES,0.1840628507295174,"Tianyi Lin, Chi Jin, and Michael Jordan. On gradient descent ascent for nonconvex-concave minimax
problems.
In Hal Daumé III and Aarti Singh (eds.), Proceedings of the 37th International
Conference on Machine Learning, volume 119 of Proceedings of Machine Learning Research, pp.
6083–6093. PMLR, 2020."
REFERENCES,0.18518518518518517,"Pierre-Louis Lions and Bertrand Mercier. Splitting algorithms for the sum of two nonlinear operators.
SIAM Journal on Numerical Analysis, 16(6):964–979, 1979."
REFERENCES,0.186307519640853,"Mingrui Liu, Hassan Raﬁque, Qihang Lin, and Tianbao Yang. First-order convergence theory for
weakly-convex-weakly-concave min-max problems. Journal of Machine Learning Research, 22
(169):1–34, 2021."
REFERENCES,0.18742985409652077,"Nicolas Loizou, Hugo Berard, Alexia Jolicoeur-Martineau, Pascal Vincent, Simon Lacoste-Julien, and
Ioannis Mitliagkas. Stochastic hamiltonian gradient methods for smooth games. In International
Conference on Machine Learning, pp. 6370–6381. PMLR, 2020."
REFERENCES,0.18855218855218855,"Nicolas Loizou, Hugo Berard, Gauthier Gidel, Ioannis Mitliagkas, and Simon Lacoste-Julien. Stochas-
tic gradient descent-ascent and consensus optimization for smooth games: Convergence analysis
under expected co-coercivity. arXiv preprint arXiv:2107.00052, 2021."
REFERENCES,0.18967452300785634,"Yura Malitsky and Matthew K Tam. A forward-backward splitting method for monotone inclusions
without cocoercivity. SIAM Journal on Optimization, 30(2):1451–1472, 2020."
REFERENCES,0.19079685746352412,"Panayotis Mertikopoulos, Bruno Lecouat, Houssam Zenati, Chuan-Sheng Foo, Vijay Chandrasekhar,
and Georgios Piliouras. Optimistic mirror descent in saddle-point problems: Going the extra(-
gradient) mile. In International Conference on Learning Representations, 2019. URL https:
//openreview.net/pdf?id=Bkg8jjC9KQ."
REFERENCES,0.1919191919191919,"Lars Mescheder, Sebastian Nowozin, and Andreas Geiger. The numerics of GANs. In I. Guyon, U. V.
Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.), Advances in
Neural Information Processing Systems, volume 30. Curran Associates, 2017."
REFERENCES,0.19304152637485972,Under review as a conference paper at ICLR 2022
REFERENCES,0.1941638608305275,"Lars Mescheder, Andreas Geiger, and Sebastian Nowozin. Which training methods for GANs do
actually converge? In Jennifer Dy and Andreas Krause (eds.), Proceedings of the 35th International
Conference on Machine Learning, volume 80 of Proceedings of Machine Learning Research, pp.
3481–3490. PMLR, 2018."
REFERENCES,0.19528619528619529,"Konstantin Mishchenko, Dmitry Kovalev, Egor Shulgin, Peter Richtárik, and Yura Malitsky. Revisit-
ing stochastic extragradient. In International Conference on Artiﬁcial Intelligence and Statistics,
pp. 4573–4582. PMLR, 2020."
REFERENCES,0.19640852974186307,"Aryan Mokhtari, Asuman E Ozdaglar, and Sarath Pattathil. Convergence rate of o(1/k) for optimistic
gradient and extragradient methods in smooth convex-concave saddle point problems. SIAM
Journal on Optimization, 30(4):3230–3251, 2020."
REFERENCES,0.19753086419753085,"Renato DC Monteiro and Benar Fux Svaiter. On the complexity of the hybrid proximal extragradient
method for the iterates and the ergodic mean. SIAM Journal on Optimization, 20(6):2755–2787,
2010."
REFERENCES,0.19865319865319866,"Vaishnavh Nagarajan and J. Zico Kolter. Gradient descent GAN optimization is locally stable. In
I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett (eds.),
Advances in Neural Information Processing Systems, volume 30. Curran Associates, 2017."
REFERENCES,0.19977553310886645,"Hongseok Namkoong and John C Duchi. Stochastic gradient methods for distributionally robust
optimization with f-divergences. In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett
(eds.), Advances in Neural Information Processing Systems, volume 29. Curran Associates, 2016."
REFERENCES,0.20089786756453423,"Arkadi Nemirovski. Prox-method with rate of convergence O(1/t) for variational inequalities with
Lipschitz continuous monotone operators and smooth convex-concave saddle point problems.
SIAM Journal on Optimization, 15(1):229–251, 2004."
REFERENCES,0.20202020202020202,"Yurii Nesterov. Dual extrapolation and its applications to solving variational inequalities and related
problems. Mathematical Programming, 109(2):319–344, 2007."
REFERENCES,0.2031425364758698,"Neal Parikh and Stephen Boyd. Proximal algorithms. Foundations and Trends in Optimization, 1(3):
123–231, 2013."
REFERENCES,0.20426487093153758,"Reese Pathak and Martin J Wainwright. Fedsplit: an algorithmic framework for fast federated
optimization. In H. Larochelle, M. Ranzato, R. Hadsell, M. F. Balcan, and H. Lin (eds.), Ad-
vances in Neural Information Processing Systems, volume 33, pp. 7057–7066. Curran Asso-
ciates, Inc., 2020. URL https://proceedings.neurips.cc/paper/2020/file/
4ebd440d99504722d80de606ea8507da-Paper.pdf."
REFERENCES,0.2053872053872054,"Fabian Pedregosa and Gauthier Gidel. Adaptive three-operator splitting. In Jennifer Dy and Andreas
Krause (eds.), Proceedings of the 35th International Conference on Machine Learning, volume 80
of Proceedings of Machine Learning Research, pp. 4085–4094. PMLR, 10–15 Jul 2018."
REFERENCES,0.20650953984287318,"Fabian Pedregosa, Kilian Fatras, and Mattia Casotto. Proximal splitting meets variance reduction. In
Kamalika Chaudhuri and Masashi Sugiyama (eds.), Proceedings of the Twenty-Second Interna-
tional Conference on Artiﬁcial Intelligence and Statistics, volume 89 of Proceedings of Machine
Learning Research, pp. 1–10. PMLR, 16–18 Apr 2019."
REFERENCES,0.20763187429854096,"Emile Richard, Pierre-Andre Savalle, and Nicolas Vayatis. Estimation of simultaneously sparse and
low rank matrices. In John Langford and Joelle Pineau (eds.), Proceedings of the 29th International
Conference on Machine Learning, pp. 1351–1358. Omnipress, 2012."
REFERENCES,0.20875420875420875,"Herbert Robbins and Sutton Monro. A stochastic approximation method. The annals of mathematical
statistics, pp. 400–407, 1951."
REFERENCES,0.20987654320987653,"R Tyrrell Rockafellar. Monotone operators associated with saddle-functions and minimax problems.
Nonlinear functional analysis, 18(part 1):397–407, 1970."
REFERENCES,0.21099887766554434,"Ernest K Ryu and Stephen Boyd. Primer on monotone operator methods. Appl. Comput. Math, 15(1):
3–43, 2016."
REFERENCES,0.21212121212121213,Under review as a conference paper at ICLR 2022
REFERENCES,0.2132435465768799,"Ernest K. Ryu, Kun Yuan, and Wotao Yin. Ode analysis of stochastic gradient methods with optimism
and anchoring for minimax problems, 2020."
REFERENCES,0.2143658810325477,"Gesualdo Scutari, Francisco Facchinei, Jong-Shi Pang, and Daniel P Palomar. Real and complex
monotone communication games. IEEE Transactions on Information Theory, 60(7):4197–4231,
2014."
REFERENCES,0.21548821548821548,"Soroosh Shaﬁeezadeh-Abadeh, Peyman Mohajerin Esfahani, and Daniel Kuhn. Distributionally
robust logistic regression. In Corinna Cortes, Neil D. Lawrence, Daniel D. Lee, Masashi Sugiyama,
and Roman Garnett (eds.), Advances in Neural Information Processing Systems, volume 28, pp.
1576–1584. Curran Associates, 2015."
REFERENCES,0.2166105499438833,"Aman Sinha, Hongseok Namkoong, and John Duchi. Certifying some distributional robustness with
principled adversarial training. In International Conference on Learning Representations, 2018.
URL https://openreview.net/forum?id=Hk6kPgZA-."
REFERENCES,0.21773288439955107,"Paul Tseng. A modiﬁed forward-backward splitting method for maximal monotone mappings. SIAM
Journal on Control and Optimization, 38(2):431–446, 2000."
REFERENCES,0.21885521885521886,"Nguyen Van Dung and Bang Cong Vu. Convergence analysis of the stochastic reﬂected forward-
backward splitting algorithm. arXiv preprint arXiv:2102.08906, 2021."
REFERENCES,0.21997755331088664,"Christina Wadsworth, Francesca Vera, and Chris Piech. Achieving fairness through adversarial
learning: an application to recidivism prediction. arXiv preprint arXiv:1807.00199, 2018."
REFERENCES,0.22109988776655443,"Xiaohan Yan and Jacob Bien. Rare feature selection in high dimensions. Journal of the American
Statistical Association, 2020. Published online, to appear in print."
REFERENCES,0.2222222222222222,"Yaodong Yu, Tianyi Lin, Eric Mazumdar, and Michael I Jordan. Fast distributionally robust learning
with variance reduced min-max optimization. arXiv preprint arXiv:2104.13326, 2021."
REFERENCES,0.22334455667789002,"Alp Yurtsever, Bang Cong Vu, and Volkan Cevher. Stochastic three-composite convex minimization.
In D. Lee, M. Sugiyama, U. Luxburg, I. Guyon, and R. Garnett (eds.), Advances in Neural
Information Processing Systems, volume 29. Curran Associates, 2016."
REFERENCES,0.2244668911335578,"Brian Hu Zhang, Blake Lemoine, and Margaret Mitchell. Mitigating unwanted biases with adversarial
learning. In Proceedings of the 2018 AAAI/ACM Conference on AI, Ethics, and Society, pp. 335–
340, 2018."
REFERENCES,0.2255892255892256,"A
ML APPLICATIONS OF THE MONOTONE INCLUSION (1)"
REFERENCES,0.22671156004489337,"There are two main classes of applications of (1) in ML: optimization problems and saddle-point
games."
REFERENCES,0.22783389450056116,"Optimization Problems
In this case the monotone inclusion arises from ﬁnding the zero of a
sum of subgradients of convex functions, as discussed in Section 2. It is typical in ML to solve the
empirical risk minimization problem"
REFERENCES,0.22895622895622897,"min
x∈Rd
1
m m
X"
REFERENCES,0.23007856341189675,"j=1
fj(x) + n
X"
REFERENCES,0.23120089786756454,"i=1
ri(x)
(16)"
REFERENCES,0.23232323232323232,"over a size-m dataset. Usually, the gradient of the loss function fj for each datapoint j is Lipschitz
continuous. The terms ri may be regularizers used to reduce overﬁtting or encourage structural
properties such as sparsity or low matrix rank. They also may represent constraints on the parameters
such as nonnegativity or the being in the probability simplex. Crucially, these regularizers are rarely
differentiable. The ﬁrst-order necessary condition for the solution of (16) is"
REFERENCES,0.2334455667789001,"0 ∈∇f(x∗) + n
X"
REFERENCES,0.2345679012345679,"i=1
∂ri(x∗),
(17)"
REFERENCES,0.2356902356902357,Under review as a conference paper at ICLR 2022
REFERENCES,0.23681257014590348,where f(x) .= 1
REFERENCES,0.23793490460157127,"m
Pm
j=1 fj(x), thus ∇f(x) .= 1"
REFERENCES,0.23905723905723905,"m
Pm
j=1 ∇fj(x). The inclusion (17) is a special case
of (1), and our method may use the standard stochastic oracle for ∇f(x), namely 1
|B| X"
REFERENCES,0.24017957351290684,"j∈B
∇fj(z)"
REFERENCES,0.24130190796857465,"which subsamples a randomly selected minibatch of datapoints B ∈{1, . . . , m}."
REFERENCES,0.24242424242424243,"Games
Consider the following nonsmooth Nash equilibrium problem"
REFERENCES,0.24354657687991021,"x∗∈arg min
x∈Rdx
F(x, y∗) + n1
X"
REFERENCES,0.244668911335578,"i=1
ri(x)
and
y∗∈arg min
y∈Rdy
G(x∗, y) + n2
X"
REFERENCES,0.24579124579124578,"i=1
di(y).
(18)"
REFERENCES,0.24691358024691357,"The terms Pn1
i=1 ri(x) and Pn2
i=1 di(y) once again represent regularizers and constraints on each
player’s strategy. Note that min-max (saddle-point) problems correspond to having F(x, y) =
−G(x, y). Under appropriate convexity conditions and constraint qualiﬁcations, the solutions of (18)
correspond to the solutions of the following monotone inclusion in the form of (1):"
REFERENCES,0.24803591470258138,"0 ∈

∇xF(x∗, y∗)
∇yG(x∗, y∗) 
+"
REFERENCES,0.24915824915824916,"max{n1,n2}
X i=1"
REFERENCES,0.250280583613917," 
∂ri(x∗) × ∂di(y∗)

(19)"
REFERENCES,0.25140291806958476,"where for i > min{n1, n2} we include “dummy functions"", either ri(x) = 0 when n1 < n2 or
di(y) = 0 when n1 < n2. If the functions F and G arise as averages in the same we as f in (16),
then our method may again use a stochastic oracle for them."
REFERENCES,0.25252525252525254,"Distributionally-Robust ML
One example application of (19) is distributionally-robust ML, as
demonstrated in the numerical experiment in Section 7. The full problem statement is given in
Appendix I."
REFERENCES,0.2536475869809203,"Lagrangian Duality
Another application of (19) is constrained optimization via Lagrangian duality.
Consider"
REFERENCES,0.2547699214365881,"min
x∈Rd ("
REFERENCES,0.2558922558922559,"f(x) + n
X"
REFERENCES,0.2570145903479237,"i=1
ri(x) )"
REFERENCES,0.25813692480359146,"s.t.
hj(x) ≤0
j = 1, . . . , p."
REFERENCES,0.25925925925925924,"As in (16), f is a loss function and the ri may represent regularizers and (“simple”) constraints;
in addition, there are p functional constraints on the model parameters x. Introducing Lagrange
multipliers γ ∈Rp, the problem can be written as"
REFERENCES,0.26038159371492703,"min
x∈Rd max
γ∈Rp
+ 
"
REFERENCES,0.2615039281705948,"f(x) + n
X"
REFERENCES,0.26262626262626265,"i=1
ri(x) + p
X"
REFERENCES,0.26374859708193044,"j=1
γjhj(x) 
 ."
REFERENCES,0.2648709315375982,"Under appropriate convexity conditions and constraint-qualiﬁcations, this reduces to the following
inclusion in the form of (1):"
REFERENCES,0.265993265993266,"0 ∈
 ∇f(x) + Pp
j=1 γj∇hj(x)
−h(x) 
+ n
X i=1"
REFERENCES,0.2671156004489338," 
∂ri(x∗) × {0}
"
REFERENCES,0.26823793490460157,"where h(x) = [h1(x), h2(x), . . . , hp(x)]⊤. For certain choices of h, such as linear or quadratic
functions, the ﬁrst term above is monotone and (locally) Lipschitz continuous (Alacaoglu et al.,
2021)."
REFERENCES,0.26936026936026936,"Bilinear Games with Many Constraints
Finally, consider the bilinear saddlepoint problem subject
to multiple constraints:"
REFERENCES,0.27048260381593714,"min
x∈Rd max
y∈Rd x⊤Dy
s.t.
x ∈C1
j
j = 1, . . . , n1,"
REFERENCES,0.2716049382716049,"y ∈C2
j
j = 1, . . . , n2."
REFERENCES,0.2727272727272727,Under review as a conference paper at ICLR 2022
REFERENCES,0.2738496071829405,"Under some regularity conditions, this problem reduces to the inclusion"
REFERENCES,0.27497194163860833,"0 ∈

Dy∗ −D⊤x∗ 
+"
REFERENCES,0.2760942760942761,"max{n1,n2}
X j=1"
REFERENCES,0.2772166105499439," 
NC1
j (x∗) × NC2
j (y∗)

,"
REFERENCES,0.2783389450056117,"where we introduce additional “dummy” sets C1
j = Rd or C2
j = Rd when n1 ̸= n2. The ﬁrst term
is linear and skew symmetric, and therefore can easily be shown to be Lipschitz continuous and
monotone. If all the constraint sets are closed and convex, then the rest of the terms are maximal
monotone, then the problem is of the form (1), meaning that projective splitting may be applied,
possibly using a stochastic oracle for the ﬁrst term."
REFERENCES,0.27946127946127947,"B
ADDITIONAL RELATED WORK"
REFERENCES,0.28058361391694725,"The preprint by Bot et al. (2019) develops a stochastic version of Tseng’s method under the require-
ment that the noise variance converges to 0. In ML, this could be achieved with the use of perpetually
increasing batch sizes, a strategy that is impractical in many scenarios. The stochastic version of
FRB proposed by Van Dung & Vu (2021) has more practical noise requirements, but has stronger
assumptions on the problem which are rarely satisﬁed in ML applications: either uniform/strong
monotonicity or a bounded domain. The papers by Yurtsever et al. (2016) and Pedregosa et al.
(2019) consider stochastic variants of three-operator splitting, but require B in (1) to be cocoercive,
essentially restricting them to optimization problems."
REFERENCES,0.28170594837261503,"There are several alternatives to the (stochastic) extragradient method that reduce the number of
gradient evaluations per iteration from two to one (Hsieh et al., 2019; Malitsky & Tam, 2020; Gidel
et al., 2019). However, these methods have more stringent stepsize limits, making it unclear a priori
whether they will outperform two-step methods."
REFERENCES,0.2828282828282828,"DSEG is a stochastic version of EG (Hsieh et al., 2020). The primary innovation of DSEG is using
different stepsizes for the extrapolation and update steps, thereby resolving some of the convergence
issues affecting stochastic EG. As noted earlier, DSEG is the special case of our SPS method in which
n = 0, that is, no regularizers/constraints are present in the underlying game. The analysis in (Hsieh
et al., 2020) also did not consider the ﬁxed stepsize choice given in Theorem 2."
REFERENCES,0.2839506172839506,"In the context of GANs, several methods have been developed based on a variational inequal-
ity/monotone inclusion approach (Gidel et al., 2019; Daskalakis et al., 2018; Hsieh et al., 2019; 2020;
Böhm et al., 2020). Many of these papers point out that variational inequalities provide a principled
framework for studying the GAN training problem and correcting some of the ﬂaws in the standard
method GDA."
REFERENCES,0.2850729517396184,"C
PROOF OF THEOREM 1"
REFERENCES,0.28619528619528617,"C.1
STOCHASTIC QUASI-FEJER MONOTONICITY"
REFERENCES,0.287317620650954,"The key to the analysis is showing that the algorithm satisﬁes Stochastic Quasi-Fejer Monotonicity
(Combettes & Pesquet, 2015).
Lemma 2 ((Combettes & Pesquet, 2015), Proposition 2.3). Suppose pk is a sequence of Rd-valued
random variables deﬁned on a probability space (Ω, F, P). Let Fk = σ(p1, . . . , pk). Let F be a
nonempty, closed subset of Rd. Suppose that, for every p ∈F, there exists χk(p) ≥0, ηk(p) ≥
0, νk(p) ≥0 such that P∞
k=1 χk(p) < ∞, P∞
k=1 ηk(p) < ∞and"
REFERENCES,0.2884399551066218,"(∀k ∈N)
E[∥pk+1 −p∥2|Fk] ≤(1 + χk(p))∥pk −p∥2 −νk(p) + ηk(p)."
REFERENCES,0.2895622895622896,Then the following hold:
REFERENCES,0.29068462401795736,"1. (∀p ∈F) :
P∞
k=1 νk(p) < ∞a.s."
REFERENCES,0.29180695847362514,2. pk is bounded a.s.
REFERENCES,0.29292929292929293,"3. There exists ˜Ωsuch that P[˜Ω] = 1 and

∥pk(ω) −p∥
	
converges for every ω ∈˜Ωand
p ∈F."
REFERENCES,0.2940516273849607,Under review as a conference paper at ICLR 2022
REFERENCES,0.2951739618406285,"C.2
IMPORTANT RECURSION FOR SPS"
REFERENCES,0.2962962962962963,"The following lemma summarizes the key recursion satisﬁed by Algorithm 1, to which we will apply
Lemma 2. Recall that L is the Lipschitz constant of B.
Lemma 3. For Algorithm 1, suppose (9)–(11) hold and"
REFERENCES,0.29741863075196406,"ρk ≤ρ < 1/L.
(20) Let"
REFERENCES,0.29854096520763185,"Tk .= τ ρ n
X"
REFERENCES,0.2996632996632997,"i=1
∥yk
i −wk
i ∥2 + 1 ρτ n
X"
REFERENCES,0.30078563411896747,"i=1
∥zk −xk
i ∥2 + 2(1 −ρL)∥B(zk) −wk
n+1∥2"
REFERENCES,0.30190796857463525,"then for all p∗∈S, with probability one"
REFERENCES,0.30303030303030304,"E[∥pk+1 −p∗∥2|Fk] ≤(1 + C1α2
k + C3αkρ2
k)∥pk −p∗∥2 −αkρkTk + C2α2
k + C4αkρ2
k
(21)"
REFERENCES,0.3041526374859708,"where C1, . . . , C4 are nonegative constants deﬁned in (33), (34), (48), and (49) below, respectively."
REFERENCES,0.3052749719416386,Note that Tk is a scaled version of the approximation residual Gk deﬁned in (14).
REFERENCES,0.3063973063973064,"We proceed to ﬁrst prove Lemma 3 and then exploit the implications of Lemma 2. Referring to (10)
and (11), let N .= maxj∈1..4 Nj. To simplify the constants, we will use N in place of Nj for the
noise variance bounds given in (10)-(11)."
REFERENCES,0.3075196408529742,"C.3
UPPER BOUNDING THE GRADIENT"
REFERENCES,0.30864197530864196,"Throughout the analysis, we ﬁx some p∗= (z∗, w∗
1 . . . , w∗
n+1) ∈S. All statements are with
probability one (almost surely), but for brevity we will omit this unless it needs to be emphasized."
REFERENCES,0.30976430976430974,"In this section, we derive appropriate upper bounds for ∥∇ϕk∥2 to use in (13). We begin with ∇zϕk:"
REFERENCES,0.3108866442199775,"∥∇zϕk∥2 = n+1
X"
REFERENCES,0.31200897867564537,"i=1
yk
i

2
≤2∥yk
n+1∥2 + 2 n
X"
REFERENCES,0.31313131313131315,"i=1
yk
i

2
= 2
B(xk
n+1) + ek2 + 2 n
X"
REFERENCES,0.31425364758698093,"i=1
yk
i

2"
REFERENCES,0.3153759820426487,"≤4∥B(xk
n+1)∥2 + 2 n
X"
REFERENCES,0.3164983164983165,"i=1
yk
i

2
+ 4∥ek∥2."
REFERENCES,0.3176206509539843,"Now next take expectations with respect to Fk and Ek, and use the bound on the variance of the noise
in (11), obtaining"
REFERENCES,0.31874298540965207,"E

∥∇zϕk∥2|Fk, Ek

≤E """
REFERENCES,0.31986531986531985,"4∥B(xk
n+1)∥2 + 2 n
X"
REFERENCES,0.32098765432098764,"i=1
yk
i

2
+ 4∥ek∥2  Fk, Ek #"
REFERENCES,0.3221099887766554,"≤4(N + 1)∥B(xk
n+1)∥2 + 2 n
X"
REFERENCES,0.32323232323232326,"i=1
yk
i

2
+ 4N,"
REFERENCES,0.32435465768799104,"where we have used that yk
i is Fk-measurable for i ∈1..n. Thus, taking expectations over Ek
conditioned on Fk yields"
REFERENCES,0.3254769921436588,"E

∥∇zϕk∥2|Fk

≤4(N + 1)E[∥B(xk
n+1)∥2|Fk] + 2 n
X"
REFERENCES,0.3265993265993266,"i=1
yk
i

2
+ 4N.
(22)"
REFERENCES,0.3277216610549944,We will now bound the two terms on the right side of (22).
REFERENCES,0.3288439955106622,"C.3.1
FIRST TERM IN (22)"
REFERENCES,0.32996632996632996,"First, note that"
REFERENCES,0.33108866442199775,∥B(zk)∥2 = ∥B(zk) −B(z∗) + B(z∗))∥2
REFERENCES,0.33221099887766553,≤2∥B(zk) −B(z∗)∥2 + 2∥B(z∗)∥2
REFERENCES,0.3333333333333333,≤2L2∥zk −z∗∥2 + 2∥B(z∗)∥2
REFERENCES,0.3344556677890011,"≤2L2∥pk −p∗∥2 + 2∥B(z∗)∥2.
(23)"
REFERENCES,0.33557800224466894,Under review as a conference paper at ICLR 2022
REFERENCES,0.3367003367003367,"Now, returning to the ﬁrst term on the right of (22), we have"
REFERENCES,0.3378226711560045,"∥B(xk
n+1)∥2 = ∥B(zk) + B(xk
n+1) −B(zk)∥2"
REFERENCES,0.3389450056116723,"≤2∥B(zk)∥2 + 2∥B(xk
n+1) −B(zk)∥2"
REFERENCES,0.3400673400673401,"≤2∥B(zk)∥2 + 2L2∥xk
n+1 −zk∥2"
REFERENCES,0.34118967452300786,"≤4L2∥pk −p∗∥2 + 4∥B(z∗)∥2 + 2L2∥xk
n+1 −zk∥2
(24)"
REFERENCES,0.34231200897867564,where we have used (23) to obtain (24).
REFERENCES,0.3434343434343434,"For the third term in (24), we have from the calculation on line 7 of the algorithm that"
REFERENCES,0.3445566778900112,"xk
n+1 −zk = −ρk(rk −wk
n+1) = −ρk(B(zk) + ϵk −wk
n+1),"
REFERENCES,0.345679012345679,and therefore
REFERENCES,0.3468013468013468,"∥xk
n+1 −zk∥2 = ρ2
k∥B(zk) + ϵk −wk
n+1∥2"
REFERENCES,0.3479236812570146,"≤ρ2∥B(zk) + ϵk −wk
n+1∥2"
REFERENCES,0.3490460157126824,"≤3ρ2(∥B(zk)∥2 + ∥ϵk∥2 + ∥wk
n+1∥2)."
REFERENCES,0.3501683501683502,We next take expectations conditioned on Fk and use the noise variance bound (10) to obtain
REFERENCES,0.35129068462401797,"E

∥xk
n+1 −zk∥2 | Fk

≤E

3ρ2 
∥B(zk)∥2 + ∥ϵk∥2 + ∥wk
n+1∥2
| Fk
"
REFERENCES,0.35241301907968575,"≤3ρ2 
(N + 1)∥B(zk)∥2 + ∥wk
n+1∥2 + N

."
REFERENCES,0.35353535353535354,Therefore
REFERENCES,0.3546576879910213,"E

∥xk
n+1 −zk∥2 | Fk

≤6ρ2 
(N + 1)∥B(zk)∥2 + ∥wk
n+1 −w∗
n+1∥2 + ∥w∗
n+1∥2
+ 3ρ2N"
REFERENCES,0.3557800224466891,"= 6ρ2
2(N + 1)L2∥pk −p∗∥2 + 2(N + 1)∥B(z∗)∥2"
REFERENCES,0.3569023569023569,"+ ∥wk
n+1 −w∗
n+1∥2 + ∥B(z∗)∥2
+ 3ρ2N"
REFERENCES,0.35802469135802467,"≤6ρ2 
2(N + 1)L2∥pk −p∗∥2 + ∥wk
n+1 −w∗
n+1∥2"
REFERENCES,0.35914702581369246,+ 18ρ2(N + 1)∥B(z∗)∥2 + 3ρ2N
REFERENCES,0.3602693602693603,"≤18ρ2(N + 1)
 
(L2 + 1)∥pk −p∗∥2 + ∥B(z∗)∥2
+ 3ρ2N
(25)"
REFERENCES,0.3613916947250281,"where in the equality uses (23) and w∗
n+1 = B(z∗). Combining (24) and (25), we arrive at"
REFERENCES,0.36251402918069586,"E
hB(xk
n+1)
2  Fk
i
≤4L2
1 + 9ρ2(L2 + 1)(N + 1)

∥pk −p∗∥2"
REFERENCES,0.36363636363636365,"+ 4
 
1 + 9ρ2L2(N + 1)

∥B(z∗)∥2 + 6ρ2L2N.
(26)"
REFERENCES,0.36475869809203143,"C.3.2
SECOND TERM IN (22)"
REFERENCES,0.3658810325476992,"For i ∈1..n, line 5 of the algorithm may be rearranged into yk
i = τ −1(zk −xk
i ) + wk
i , so n
X"
REFERENCES,0.367003367003367,"i=1
yk
i

2
= n
X"
REFERENCES,0.3681257014590348,"i=1
(τ −1(zk −xk
i ) + wk
i )

2"
REFERENCES,0.36924803591470257,"≤2
τ −1
n
X"
REFERENCES,0.37037037037037035,"i=1
(zk −xk
i )

2
+ 2 n
X"
REFERENCES,0.37149270482603813,"i=1
wk
i

2"
REFERENCES,0.372615039281706,"≤2nτ −2
n
X"
REFERENCES,0.37373737373737376,"i=1
∥zk −xk
i ∥2 + 2 n
X"
REFERENCES,0.37485970819304154,"i=1
wk
i

2"
REFERENCES,0.3759820426487093,"≤4n2τ −2∥zk −z∗∥2 + 4nτ −2
n
X"
REFERENCES,0.3771043771043771,"i=1
∥z∗−xk
i ∥2 + 4n n
X"
REFERENCES,0.3782267115600449,"i=1
∥wk
i −w∗
i ∥2 + 4 n
X"
REFERENCES,0.3793490460157127,"i=1
w∗
i

2"
REFERENCES,0.38047138047138046,"≤4n2(τ −2 + 1)∥pk −p∗∥2 + 4nτ −2
n
X"
REFERENCES,0.38159371492704824,"i=1
∥z∗−xk
i ∥2 + 4 n
X"
REFERENCES,0.38271604938271603,"i=1
w∗
i

2
.
(27)"
REFERENCES,0.3838383838383838,Under review as a conference paper at ICLR 2022
REFERENCES,0.38496071829405165,"By the deﬁnition of the solution set S in (5), w∗
i ∈Ai(z∗), so z∗+ τw∗
i ∈(I + τAi)(z∗), and since
the resolvent is single-valued (Bauschke & Combettes, 2017, Cor. 23.9) we therefore obtain"
REFERENCES,0.38608305274971944,"z∗= (I + τAi)−1(I + τAi)(z∗) = JτAi(z∗+ τw∗
i )."
REFERENCES,0.3872053872053872,"From lines 3 and 4 of the algorithm, we also have xk
i = JτAi(zk + τwk
i ) for i ∈1..n. Thus, using
the nonexpansiveness of the resolvent (Bauschke & Combettes, 2017, Def. 4.1 and Cor. 23.9), we
have n
X"
REFERENCES,0.388327721661055,"i=1
∥z∗−xk
i ∥2 = n
X i=1"
REFERENCES,0.3894500561167228,"JτAi(zk + τwk
i ) −JτAi(z∗+ τw∗
i )
2 ≤ n
X"
REFERENCES,0.39057239057239057,"i=1
∥zk + τwk
i −z∗−τw∗
i ∥2 = n
X"
REFERENCES,0.39169472502805835,"i=1
∥zk −z∗+ τ(wk
i −w∗
i )∥2"
REFERENCES,0.39281705948372614,"≤2n∥zk −z∗∥2 + 2τ 2
n
X"
REFERENCES,0.3939393939393939,"i=1
∥wk
i −w∗
i ∥2"
REFERENCES,0.3950617283950617,"≤2(n + τ 2)∥pk −p∗∥2.
(28)"
REFERENCES,0.3961840628507295,"Combining (27) and (28) yields  n
X"
REFERENCES,0.39730639730639733,"i=1
yk
i

2
≤12n2τ −2(n + τ 2)∥pk −p∗∥2 + 4 n
X"
REFERENCES,0.3984287317620651,"i=1
w∗
i

2
.
(29)"
REFERENCES,0.3995510662177329,Combining (26) and (29) with (22) yields
REFERENCES,0.4006734006734007,"E

∥∇zϕk∥2 | Fk

≤24

(1 + 9ρ2)(L2 + 1)2(N + 1)2 + n2τ −2(n + τ 2)

∥pk −p∗∥2"
REFERENCES,0.40179573512906847,"+ 16(N + 1)
 
1 + 9ρ2L2(N + 1)

∥B(z∗)∥2 + 8 n
X"
REFERENCES,0.40291806958473625,"i=1
w∗
i

2"
REFERENCES,0.40404040404040403,"+ 24ρ2L2(N + 1)N + 4N.
(30)"
REFERENCES,0.4051627384960718,"C.3.3
DUAL GRADIENT NORM"
REFERENCES,0.4062850729517396,"Considering that ∇ϕk is taken with respect to the subspace P, the gradients with respect to the dual
variables are — see for example Eckstein & Svaiter (2009) — for each i ∈1..(n + 1),"
REFERENCES,0.4074074074074074,"∥∇wiϕk∥2 =
xk
i −
1
n + 1 n+1
X"
REFERENCES,0.40852974186307517,"j=1
xk
j

2
=

1
n + 1 n+1
X"
REFERENCES,0.409652076318743,"j=1
(xk
i −xk
j )

2 ≤ n+1
X"
REFERENCES,0.4107744107744108,"j=1
∥xk
i −xk
j ∥2 ≤2 n+1
X j=1"
REFERENCES,0.4118967452300786," 
∥xk
i −zk∥2 + ∥zk −xk
j ∥2"
REFERENCES,0.41301907968574636,"Summing this inequality for i ∈1..(n + 1) and collecting terms yields n+1
X"
REFERENCES,0.41414141414141414,"i=1
∥∇wiϕk∥2 ≤4(n + 1) n+1
X"
REFERENCES,0.4152637485970819,"i=1
∥xk
i −zk∥2,"
REFERENCES,0.4163860830527497,Under review as a conference paper at ICLR 2022
REFERENCES,0.4175084175084175,"so taking expectations conditioned on Fk produces n+1
X"
REFERENCES,0.4186307519640853,"i=1
E[∥∇wiϕk∥2 | Fk] ≤4(n + 1) n+1
X"
REFERENCES,0.41975308641975306,"i=1
E[∥xk
i −zk∥2 | Fk]"
REFERENCES,0.4208754208754209,"≤4(n + 1)E[∥xk
n+1 −zk∥2 | Fk] + 4(n + 1) n
X"
REFERENCES,0.4219977553310887,"i=1
E[∥xk
i −zk∥2 | Fk]"
REFERENCES,0.42312008978675647,"≤4(n + 1)E[∥xk
n+1 −zk∥2 | Fk]"
REFERENCES,0.42424242424242425,"+ 8(n + 1) n
X"
REFERENCES,0.42536475869809204,"i=1
E[∥xk
i −z∗∥2 | Fk] + 8(n + 1)2∥zk −z∗∥2"
REFERENCES,0.4264870931537598,"≤4(n + 1)E[∥xk
n+1 −zk∥2|Fk]"
REFERENCES,0.4276094276094276,"+ 8(n + 1) n
X"
REFERENCES,0.4287317620650954,"i=1
E[∥xk
i −z∗∥2|Fk] + 8(n + 1)2∥pk −p∗∥2"
REFERENCES,0.4298540965207632,"≤8(n + 1)

3n + 2τ 2 + 1 + 9ρ2(L2 + 1)(N + 1)

∥pk −p∗∥2"
REFERENCES,0.43097643097643096,"+ 72ρ2(n + 1)(N + 1)∥B(z∗)∥2 + 12ρ2(n + 1)N,
(31)"
REFERENCES,0.43209876543209874,where the ﬁnal inequality employs (25) and (28).
REFERENCES,0.4332210998877666,"All told, using (30) and (31) and simplifying the constants, one obtains"
REFERENCES,0.43434343434343436,"E[∥∇ϕk∥2 | Fk] = E[∥∇zϕk∥2 | Fk] + n+1
X"
REFERENCES,0.43546576879910215,"i=1
E[∥∇wiϕk∥2|Fk]"
REFERENCES,0.43658810325476993,"≤C1∥pk −p∗∥2 + C2,
(32) where"
REFERENCES,0.4377104377104377,C1 = 24(1 + 10ρ2)(n + 1)(L2 + 1)2(N + 1)2
REFERENCES,0.4388327721661055,"+ 8(n + 1)
 
2τ 2 + 6(n + 1) + 1 + 3(n + 1)2τ −2
(33) and"
REFERENCES,0.4399551066217733,"C2 = 16(N + 1)

1 + 4ρ2(n + 1) + 9ρ2L2(N + 1)

∥B(z∗)∥2 + 8∥ n
X"
REFERENCES,0.44107744107744107,"i=1
w∗
i ∥2"
REFERENCES,0.44219977553310885,"+ 12ρ2N(2L2(N + 1) + n + 1) + 4N.
(34)"
REFERENCES,0.44332210998877664,"C.4
LOWER BOUND FOR ϕk-GAP"
REFERENCES,0.4444444444444444,"Recalling (13), that is,"
REFERENCES,0.44556677890011226,"∥pk+1 −p∗∥2 = ∥pk −p∗∥2 −2αk(ϕk(pk) −ϕk(p∗)) + α2
k∥∇ϕk∥2."
REFERENCES,0.44668911335578004,We may use the gradient bound from (32) to obtain
REFERENCES,0.4478114478114478,"E[∥pk+1 −p∗∥2 | Fk] ≤(1 + C1α2
k)∥pk −p∗∥2 −2αkE[ϕk(pk) −ϕk(p∗) | Fk] + C2α2
k.
(35)"
REFERENCES,0.4489337822671156,"We now focus on ﬁnding a lower bound for the term E[ϕk(pk) −ϕk(p∗) | Fk], which we call the
“ϕk-gap”. Recall that for p = (z, w1, . . . , wn+1),"
REFERENCES,0.4500561167227834,"ϕk(p) = n+1
X"
REFERENCES,0.4511784511784512,"i=1
⟨z −xk
i , yk
i −wi⟩."
REFERENCES,0.45230078563411896,"For each i ∈1..(n+1), deﬁne ϕi,k(p) .= ⟨z −xk
i , yk
i −wi⟩. We will call E[ϕi,k(pk)−ϕi,k(p∗) | Fk]
the “ϕi,k-gap”. Note that ϕk(p) = Pn+1
i=1 ϕi,k(p)."
REFERENCES,0.45342312008978675,Under review as a conference paper at ICLR 2022
REFERENCES,0.45454545454545453,"C.5
LOWER BOUND FOR ϕi,k-GAP OVER i ∈1..n"
REFERENCES,0.4556677890011223,"For i ∈1..n, we have from line 5 of the algorithm that"
REFERENCES,0.4567901234567901,"zk −xk
i = τ(yk
i −wk
i )."
REFERENCES,0.45791245791245794,"Since ϕi,k(pk) = ⟨zk −xk
i , yk
i −wk
i ⟩, one may conclude that for i ∈1..n,"
REFERENCES,0.4590347923681257,"ϕi,k(pk) = τ"
REFERENCES,0.4601571268237935,"2∥yk
i −wk
i ∥2 + 1"
REFERENCES,0.4612794612794613,"2τ ∥zk −xk
i ∥2."
REFERENCES,0.4624017957351291,"On the other hand, for p∗∈S and i ∈1..n, one also has"
REFERENCES,0.46352413019079686,"−ϕi,k(p∗) = ⟨z∗−xk
i , w∗
i −yk
i ⟩≥0
(36)"
REFERENCES,0.46464646464646464,"by the monotonicity of Ai. Therefore, for i ∈1..n, it holds that"
REFERENCES,0.4657687991021324,"ϕi,k(pk) −ϕi,k(p∗) ≥τ"
REFERENCES,0.4668911335578002,"2∥yk
i −wk
i ∥2 + 1"
REFERENCES,0.468013468013468,"2τ ∥zk −xk
i ∥2,"
REFERENCES,0.4691358024691358,and taking expectations conditioned on Fk leads to
REFERENCES,0.4702581369248036,"E[ϕi,k(pk) −ϕi,k(p∗) | Fk] ≥τ"
REFERENCES,0.4713804713804714,"2∥yk
i −wk
i ∥2 + 1"
REFERENCES,0.4725028058361392,"2τ ∥zk −xk
i ∥2
(37)"
REFERENCES,0.47362514029180697,"where we have used that xk
i and yk
i are both Fk-measurable for i ∈1..n."
REFERENCES,0.47474747474747475,"C.6
LOWER BOUND FOR ϕn+1,k-GAP"
REFERENCES,0.47586980920314254,"From lines 6-7 of the algorithm, we have"
REFERENCES,0.4769921436588103,"zk −xk
n+1 = ρk(B(zk) −wk
n+1 + ϵk)."
REFERENCES,0.4781144781144781,"Therefore,"
REFERENCES,0.4792368125701459,"ϕn+1,k(pk) = ⟨zk −xk
n+1, yk
n+1 −wk
n+1⟩
(38)"
REFERENCES,0.48035914702581367,"= ⟨zk −xk
n+1, B(zk) −wk
n+1⟩+ ⟨zk −xk
n+1, yk
n+1 −B(zk)⟩"
REFERENCES,0.48148148148148145,"= ρk⟨B(zk) −wk
n+1 + ϵk, B(zk) −wk
n+1⟩+ ⟨zk −xk
n+1, yk
n+1 −B(zk)⟩"
REFERENCES,0.4826038159371493,"= ρk∥B(zk) −wk
n+1∥2 + ⟨zk −xk
n+1, yk
n+1 −B(zk)⟩+ ρk⟨ϵk, B(zk) −wk
n+1⟩"
REFERENCES,0.4837261503928171,"(a)= ρk∥B(zk) −wk
n+1∥2 + ⟨zk −xk
n+1, B(xk
n+1) −B(zk)⟩+ ⟨zk −xk
n+1, ek⟩"
REFERENCES,0.48484848484848486,"+ ρk⟨ϵk, B(zk) −wk
n+1⟩"
REFERENCES,0.48597081930415265,"≥ρk∥B(zk) −wk
n+1∥2 −L∥zk −xk
n+1∥2 + ⟨zk −xk
n+1, ek⟩"
REFERENCES,0.48709315375982043,"+ ρk⟨ϵk, B(zk) −wk
n+1⟩"
REFERENCES,0.4882154882154882,"= ρk∥B(zk) −wk
n+1∥2 −L∥ρk(B(zk) −wk
n+1 + ϵk)∥2 + ⟨zk −xk
n+1, ek⟩"
REFERENCES,0.489337822671156,"+ ρk⟨ϵk, B(zk) −wk
n+1⟩"
REFERENCES,0.4904601571268238,"= ρk∥B(zk) −wk
n+1∥2 −ρ2
kL∥B(zk) −wk
n+1 + ϵk∥2 + ⟨zk −xk
n+1, ek⟩"
REFERENCES,0.49158249158249157,"+ ρk⟨ϵk, B(zk) −wk
n+1⟩"
REFERENCES,0.49270482603815935,"= ρk(1 −ρkL)∥B(zk) −wk
n+1∥2 −ρ2
kL∥ϵk∥2 + ⟨zk −xk
n+1, ek⟩"
REFERENCES,0.49382716049382713,"+ ρk(1 −2ρkL)⟨ϵk, B(zk) −wk
n+1⟩,
(39)"
REFERENCES,0.494949494949495,"where equality (a) uses line 8 of the algorithm and the inequality employs the Cauchy-Schwartz
inequality followed by Lipschitz continuity of B."
REFERENCES,0.49607182940516276,"On the other hand,"
REFERENCES,0.49719416386083054,"−ϕn+1,k(p∗) = ⟨z∗−xk
n+1, w∗
n+1 −yk
n+1⟩"
REFERENCES,0.4983164983164983,"= ⟨z∗−xk
n+1, B(z∗) −B(xk
i )⟩+ ⟨xk
n+1 −z∗, ek⟩"
REFERENCES,0.4994388327721661,"≥⟨xk
n+1 −z∗, ek⟩,
(40)"
REFERENCES,0.500561167227834,Under review as a conference paper at ICLR 2022
REFERENCES,0.5016835016835017,"where the second equality uses line 8 of the algorithm and the inequality follows from the monotonicity
of B."
REFERENCES,0.5028058361391695,"Combining (39) and (40) yields
ϕn+1,k(pk) −ϕn+1,k(p∗) ≥ρk(1 −ρkL)∥B(zk) −wk
n+1∥2 + ρk(1 −2ρkL)⟨ϵk, B(zk) −wk
n+1⟩"
REFERENCES,0.5039281705948373,"+ ⟨zk −xk
n+1, ek⟩+ ⟨xk
n+1 −z∗, ek⟩−ρ2
kL∥ϵk∥2"
REFERENCES,0.5050505050505051,"= ρk(1 −ρkL)∥B(zk) −wk
n+1∥2 −ρ2
kL∥ϵk∥2"
REFERENCES,0.5061728395061729,"+ ρk(1 −2ρkL)⟨ϵk, B(zk) −wk
n+1⟩+ ⟨zk −z∗, ek⟩.
(41)"
REFERENCES,0.5072951739618407,"Now, if we take expectations conditioned on Fk and use (9), we obtain
E

⟨zk −z∗, ek⟩
 Fk

= ⟨zk −z∗, E[ek | Fk]⟩= 0.
(42)
Similarly, (9) also yields
E

⟨ϵk, B(zk) −wk
n+1⟩
 Fk

=

E[ϵk|Fk], B(zk) −wk
n+1

= 0.
(43)
Thus, using (42) and (43) and taking expectations of (41) yields
E[ϕn+1,k(pk) −ϕn+1,k(p∗) | Fk] ≥ρk(1 −ρkL)∥B(zk) −wk
n+1∥2 −ρ2
kLE[∥ϵk∥2|Fk]"
REFERENCES,0.5084175084175084,"≥ρk(1 −ρL)∥B(zk) −wk
n+1∥2 −ρ2
kNL(1 + ∥B(zk)∥2),
(44)
where in the second inequality we used (12) and the noise variance bound (10). Recall from (12) that
1 −ρL > 0."
REFERENCES,0.5095398428731762,"Next, we remark that
∥B(zk)∥2 = ∥B(zk) −B(z∗) + B(z∗)∥2"
REFERENCES,0.510662177328844,"≤2L2∥zk −z∗∥2 + 2∥B(z∗)∥2 ≤2L2∥pk −p∗∥2 + 2∥B(z∗)∥2.
Substituting this inequality into (44) yields
E[ϕn+1,k(pk) −ϕn+1,k(p∗)|Fk] ≥ρk(1 −ρL)∥B(zk) −wk
n+1∥2"
REFERENCES,0.5117845117845118,"−2ρ2
kNL3∥pk −p∗∥2 −ρ2
kNL(1 + 2∥B(z∗)∥2).
(45)"
REFERENCES,0.5129068462401796,"Finalizing the lower bound on the ϕk-gap
Summing (37) over i ∈1..n and using (45) yields"
REFERENCES,0.5140291806958474,"E[ϕk(pk) −ϕk(p∗)|Fk] = n+1
X"
REFERENCES,0.5151515151515151,"i=1
E[ϕi,k(pk) −ϕi,k(p∗)|Fk] ≥τ 2 n
X"
REFERENCES,0.5162738496071829,"i=1
∥yk
i −wk
i ∥2 + 1 2τ n
X"
REFERENCES,0.5173961840628507,"i=1
∥zk −xk
i ∥2"
REFERENCES,0.5185185185185185,"+ ρk(1 −ρL)∥B(zk) −wk
n+1∥2 −2ρ2
kNL3∥pk −p∗∥2"
REFERENCES,0.5196408529741863,"−ρ2
kNL(1 + 2∥B(z∗)∥2).
(46)"
REFERENCES,0.5207631874298541,"C.7
ESTABLISHING STOCHASTIC QUASI-FEJER MONOTONICITY"
REFERENCES,0.5218855218855218,"Returning to (35),
E[∥pk+1 −p∗∥2 | Fk] ≤(1 + C1α2
k)∥pk −p∗∥2 −2αkE[ϕk(pk) −ϕk(p∗) | Fk] + C2α2
k,
we may now substitute (46) for the expectation on the right-hand side. First, deﬁne"
REFERENCES,0.5230078563411896,"Tk .= τ ρ n
X"
REFERENCES,0.5241301907968574,"i=1
∥yk
i −wk
i ∥2 + 1 ρτ n
X"
REFERENCES,0.5252525252525253,"i=1
∥zk −xk
i ∥2 + 2(1 −ρL)∥B(zk) −wk
n+1∥2,"
REFERENCES,0.5263748597081931,"after which we may use (46) in (35) to yield
E[∥pk+1 −p∗∥2 | Fk] ≤(1 + C1α2
k + C3αkρ2
k)∥pk −p∗∥2 −αkρkTk + C2α2
k + C4αkρ2
k
(47)
where C1 and C2 are deﬁned as before in (33) and (34) and
C3 = 4NL3
(48)"
REFERENCES,0.5274971941638609,"C4 = 2NL(1 + 2∥B(z∗)∥2).
(49)
This completes the proof of Lemma 3."
REFERENCES,0.5286195286195287,Under review as a conference paper at ICLR 2022
REFERENCES,0.5297418630751964,"C.8
A CONVERGENCE LEMMA"
REFERENCES,0.5308641975308642,"Before establishing almost-sure convergence, we need the following lemma to derive convergence
of the iterates from convergence of Tk deﬁned above. Note that a more elaborate result would be
needed in an inﬁnite-dimensional setting."
REFERENCES,0.531986531986532,"Lemma 4. For deterministic sequences zk ∈R(n+1)d, {(wk
i )n+1
i=1 } ∈P, and {(xk
i , yk
i )n+1
i=1 } ∈
R2(n+1)d, suppose that yk
i ∈Ai(xk
i ) for i ∈1..n, Pn+1
i=1 wk
i = 0, ξ1 n
X"
REFERENCES,0.5331088664421998,"i=1
∥yk
i −wk
i ∥2 + ξ2 n
X"
REFERENCES,0.5342312008978676,"i=1
∥zk −xk
i ∥2 + ξ3∥B(zk) −wk
n+1∥2 →0
(50)"
REFERENCES,0.5353535353535354,"for scalars ξ1, ξ2, ξ3 > 0, and pk .= (zk, wk
1, . . . , wk
n+1) →ˆp .= (ˆz, ˆw1, . . . , ˆwn+1). Then ˆp ∈S."
REFERENCES,0.5364758698092031,"Proof. Fix any i ∈{1, . . . , n}. Since ∥yk
i −wk
i ∥→0 by (50) and wk
i →ˆwi, we also have
yk
i →ˆwi. Similarly, (50) also implies that ∥zk −xk
i ∥→0, so from zk →ˆz we also have xk
i →ˆz.
Since yk
i ∈Ai(xk
i ) and (xk
i , yk
i ) →(ˆz, ˆwi), (Bauschke & Combettes, 2017, Prop. 20.37) implies
ˆwi ∈Ai(ˆz). Since i was arbitrary, the preceding conclusions hold for i ∈1..n."
REFERENCES,0.5375982042648709,"Now, (50) also implies that ∥B(zk) −wk
n+1∥→0. Therefore, since wk
n+1 →ˆwn+1, we also have
B(zk) →ˆwn+1. Much as before, since (zk, B(zk)) →(ˆz, ˆwn+1), we may apply (Bauschke &
Combettes, 2017, Prop. 20.37) to conclude that that ˆwn+1 = B(ˆz)."
REFERENCES,0.5387205387205387,"Since the linear subspace P deﬁned in (6) must be closed, the limit (ˆz, ˆw1, . . . , ˆwn+1) of
{(zk, wk
1, . . . , wk
n+1)} ⊂P must be in P, hence Pn+1
i=1 ˆwi = 0."
REFERENCES,0.5398428731762065,"Thus, the point ˆp = (ˆz, ˆw1, . . . , ˆwn+1) satisﬁes ˆwi ∈Ai(ˆz) for i ∈1..n, ˆwn+1 = B(ˆz), and
Pn+1
i=1 ˆwi = 0. These are the three conditions deﬁning membership in S from (5), so ˆp ∈S."
REFERENCES,0.5409652076318743,"C.9
FINISHING THE PROOF OF THEOREM 1"
REFERENCES,0.5420875420875421,Given P
REFERENCES,0.5432098765432098,"k α2
k < ∞, and P αkρ2
k < ∞, (47) satisﬁes the conditions of Stochastic Quasi-Fejer
Monotonicity as given in Lemma 2. By applying Lemma 2, we conclude that there exist Ω1, Ω2, Ω3
such that P[Ωi] = 1 for i = 1, 2, 3 and"
REFERENCES,0.5443322109988776,"1. for all v ∈Ω1 ∞
X"
REFERENCES,0.5454545454545454,"k=1
αkρkTk(v) < ∞,
(51)"
REFERENCES,0.5465768799102132,"2. for all v ∈Ω2, and p∗∈S, ∥pk(v) −p∗∥converges to a ﬁnite nonnegative random-variable,"
REFERENCES,0.547699214365881,"3. for all v ∈Ω3, pk(v) remains bounded."
REFERENCES,0.5488215488215489,"Since P∞
k=1 αkρk = ∞, (51) implies that for all v ∈Ω1 there exists a subsequence qk(v) such that"
REFERENCES,0.5499438832772167,"Tqk(v) →0.
(52)"
REFERENCES,0.5510662177328844,"Let Ω′ = Ω1 ∩Ω2 ∩Ω3 and note that P[Ω′] = 1. Choose v ∈Ω′. Since pk(v) remains bounded, so
does pqk(v)(v) for qk(v) deﬁned above in (52). Thus there exists a subsequence rk(v) ⊆qk(v) and
ˆp(v) ∈R(n+2)d such that prk(v)(v) →ˆp(v). But since Tqk(v) →0, it also follows that Trk(v) →0,
that is, τ
ρ n
X"
REFERENCES,0.5521885521885522,"i=1
∥yrk(v)
i
(v) −wrk(v)
i
(v)∥2 + 1 ρτ n
X"
REFERENCES,0.55331088664422,"i=1
∥zrk(v)(v) −xrk(v)
i
(v)∥2"
REFERENCES,0.5544332210998878,"+ 2(1 −ρL)∥B(zrk(v)(v)) −wrk(v)
n+1 (v)∥2 →0."
REFERENCES,0.5555555555555556,We then have from Lemma 4 that ˆp(v) ∈S.
REFERENCES,0.5566778900112234,Under review as a conference paper at ICLR 2022
REFERENCES,0.5578002244668911,"Since prk(v)(v) →ˆp(v), it follows that ∥prk(v)(v)−ˆp(v)∥→0. But since ˆp(v) ∈S, ∥pk(v)−ˆp(v)∥
converges by point 2 above. Thus"
REFERENCES,0.5589225589225589,"lim
k→∞∥pk(v) −ˆp(v)∥= lim
k→∞∥prk(v)(v) −ˆp(v)∥= 0."
REFERENCES,0.5600448933782267,"Therefore pk(v) →ˆp(v) ∈S. Thus there exists ˆp ∈S such that pk →ˆp a.s., which completes the
proof of Theorem 1."
REFERENCES,0.5611672278338945,"C.10
TWO ADDITIONAL RESULTS"
REFERENCES,0.5622895622895623,"In this section, we prove two additional useful results about SPS. First, that xk
i →ˆz (a.s.) for
i = 1, . . . , n. Second, that Gk →0 (a.s.)."
REFERENCES,0.5634118967452301,"Note that
xk
i = JτAi(zk + τwk
i )"
REFERENCES,0.5645342312008979,"and since zk and wk
i convergence a.s., so does xk
i . Consider the subsequence qk(v) such that (52)
holds. Then
zqk(v) −xqk(v)
i
→0"
REFERENCES,0.5656565656565656,"thus
xqk(v)
i
→ˆz."
REFERENCES,0.5667789001122334,"Since xk
i converges to some limit (a.s.), that limit must be ˆz."
REFERENCES,0.5679012345679012,Recall that
REFERENCES,0.569023569023569,"Gk .= Pn
i=1 ∥yk
i −wk
i ∥2 + Pn
i=1 ∥zk −xk
i ∥2 + ∥B(zk) −wk
n+1∥2."
REFERENCES,0.5701459034792368,"We have shown that zk and xk
i share the same limit for i = 1, . . . , n (a.s.). Therefore zk −xk
i →0
(a.s.). Since
yk
i −wk
i = τ −1(zk −xk
i ),"
REFERENCES,0.5712682379349046,"it follows that yk
i −wk
i →0 (a.s.) for i = 1, . . . , n. Therefore"
REFERENCES,0.5723905723905723,Gk →∥B(ˆz) −ˆwn+1∥2.
REFERENCES,0.5735129068462402,"But since (z, ˆw1, . . . , ˆwn+1) ∈S, ˆwn+1 = B(ˆz) implying that Gk →0 (a.s.)."
REFERENCES,0.574635241301908,"D
PROOF OF LEMMA 1"
REFERENCES,0.5757575757575758,"If Gk = 0, then"
REFERENCES,0.5768799102132436,"∀i = 1, . . . , n :
yk
i = wk
i and zk = xk
i .
(53)"
REFERENCES,0.5780022446689114,"Since yk
i ∈Ai(xk
i ) for i = 1, . . . , n, (53) implies that that"
REFERENCES,0.5791245791245792,"∀i ∈1..n :
wk
i ∈Ai(zk).
(54)"
REFERENCES,0.5802469135802469,"Furthermore Gk = 0 also implies that wk
n+1 = B(zk). Finally, since Pn+1
i=1 wk
i = 0, we have that"
REFERENCES,0.5813692480359147,"(zk, wk
1, . . . , wk
n+1) ∈S."
REFERENCES,0.5824915824915825,"Conversely, suppose (zk, wk
1, . . . , wk
n+1) ∈S. The deﬁnition of S implies that B(zk) = wk
n+1 and
furthermore that wk
i ∈Ai(zk) for i ∈1..n. For any i ∈1..n, considering line 3 of Algorithm 1,
we may write tk
i = zk + τwk
i ∈(I + τAi)(zk), implying zk ∈(I + τAi)−1(tk
i ). But since the
resolvent JτAi = (I + τAi)−1 is single-valued (Bauschke & Combettes, 2017, Prop. 23.8), we must
have zk = (I + τAi)−1(tk
i ). Thus, by line 4, we have xk
i = zk. We may also derive from line 5 that"
REFERENCES,0.5836139169472503,"yk
i = τ −1(tk
i −xk
i ) = τ −1(zk + τwk
i −zk) = wk
i ."
REFERENCES,0.5847362514029181,"Thus, since xk
i = zk and yk
i = wk
i for i = 1, . . . , n and wk
n+1 = B(zk), we have that Gk = 0."
REFERENCES,0.5858585858585859,Under review as a conference paper at ICLR 2022
REFERENCES,0.5869809203142536,"E
PROOF OF THEOREM 2"
REFERENCES,0.5881032547699214,"In addition to the proof, we provide a more detailed statement of the theorem:
Theorem 3. Fix the total iterations K ≥1 of Algorithm 1 and set"
REFERENCES,0.5892255892255892,"∀k = 1, . . . , K :
ρk = ρ .= min

K−1/4, 1"
L,0.590347923681257,2L
L,0.5914702581369248,"
(55)"
L,0.5925925925925926,"∀k = 1, . . . , K :
αk = α .= Cfρ2
(56)"
L,0.5937149270482603,"for some Cf > 0. Suppose (9)-(11) hold. Then for any p∗∈S,"
K,0.5948372615039281,"1
K K
X"
K,0.5959595959595959,"j=1
E[Gj] ≤8L3 exp (Cf(C1 + C3))"
K,0.5970819304152637,"Cf min{τ, τ −1}K"
K,0.5982042648709316,"
∥p1 −p∗∥2 + CfC2 + C4"
K,0.5993265993265994,CfC1 + C3
K,0.6004489337822672,"
for K < (2L)4
(57)"
K,0.6015712682379349,"1
K K
X"
K,0.6026936026936027,"j=1
E[Gj] ≤exp (Cf(C1 + C3))"
K,0.6038159371492705,"Cf min{τ, τ −1}K1/4"
K,0.6049382716049383,"
∥p1 −p∗∥2 + CfC2 + C4"
K,0.6060606060606061,CfC1 + C3
K,0.6071829405162739,"
for K ≥(2L)4. (58)"
K,0.6083052749719416,"where Gk is the approximation residual deﬁned in (14), and C1, C2, C3, C4 are the nonegative
constants deﬁned in (33), (34), (48), and (49), respectively. Therefore,"
K,0.6094276094276094,"1
K K
X"
K,0.6105499438832772,"j=1
E[Gj] = O(K−1/4)."
K,0.611672278338945,"Proof. Fix αk = α and ρk = ρ, where α and ρ are the respective right-hand sides of (55)-(56).
Lemma 3 implies that (21) so long as (9)-(11) hold and the stepsize ρ satisﬁes ρ < L−1. Since"
K,0.6127946127946128,"ρ = min

K−1/4, 1"
L,0.6139169472502806,"2L 
≤1 2L,"
L,0.6150392817059483,we conclude that (21) applies.
L,0.6161616161616161,"Rewriting (21) with αk = α and ρk = ρ, we have"
L,0.6172839506172839,E[∥pk+1 −p∗∥2 | Fk] ≤(1 + C1α2 + C3αρ2)∥pk −p∗∥2 −αρTk + C2α2 + C4αρ2.
L,0.6184062850729517,"Therefore, taking expectations over Fk, we have"
L,0.6195286195286195,"E∥pk+1 −p∗∥2 ≤(1 + C1α2 + C3αρ2)E∥pk −p∗∥2 −αρETk + C2α2 + C4αρ2.
(59)"
L,0.6206509539842873,Recall that
L,0.621773288439955,"Tk .= τ ρ n
X"
L,0.622895622895623,"i=1
∥yk
i −wk
i ∥2 + 1 ρτ n
X"
L,0.6240179573512907,"i=1
∥zk −xk
i ∥2 + 2(1 −ρL)∥B(zk) −wk
n+1∥2,"
L,0.6251402918069585,"where for the ﬁrst two terms we have simply set ρ = ρ because the stepsize is constant. However,
for the ﬁnal term, we will still use an upper bound, ρ, on ρ. In the current setting, we know that
ρ ≤(1/2)L−1 and therefore we may set ρ = (1/2)L−1. Thus 1 −ρL = 1/2, leading to"
L,0.6262626262626263,"ρETk = τ n
X"
L,0.6273849607182941,"i=1
E∥yk
i −wk
i ∥2 + τ −1
n
X"
L,0.6285072951739619,"i=1
E∥zk −xk
i ∥2 + ρE∥B(zk) −wk
n+1∥2. Let"
L,0.6296296296296297,"Uk .= E∥B(zk) −wk
n+1∥2
Wk .= τ n
X"
L,0.6307519640852974,"i=1
E∥yk
i −wk
i ∥2 + τ −1
n
X"
L,0.6318742985409652,"i=1
E∥zk −xk
i ∥2,"
L,0.632996632996633,so that
L,0.6341189674523008,"ρETk = ρUk + Wk,"
L,0.6352413019079686,and also let
L,0.6363636363636364,Vk .= E∥pk −p∗∥2.
L,0.6374859708193041,Under review as a conference paper at ICLR 2022
L,0.6386083052749719,Using these deﬁnitions in (59) we write
L,0.6397306397306397,Vk+1 ≤(1 + C1α2 + C3αρ2)Vk −αρUk −αWk + C2α2 + C4αρ2.
L,0.6408529741863075,"Therefore,"
L,0.6419753086419753,Vk+1 + αρUk + αWk ≤(1 + C1α2 + C3αρ2)Vk + C2α2 + C4αρ2
L,0.6430976430976431,"⇐⇒Vk+1 + αρ k
X"
L,0.6442199775533108,"j=1
Uj + α k
X"
L,0.6453423120089786,"j=1
Wj ≤(1 + C1α2 + C3αρ2)Vk + αρ k−1
X"
L,0.6464646464646465,"j=1
Uj + α k−1
X"
L,0.6475869809203143,"j=1
Wj"
L,0.6487093153759821,+ C2α2 + C4αρ2
L,0.6498316498316499,≤(1 + C1α2 + C3αρ2) 
L,0.6509539842873177,"Vk + αρ k−1
X"
L,0.6520763187429854,"j=1
Uj + α k−1
X"
L,0.6531986531986532,"j=1
Wj  "
L,0.654320987654321,"+ C2α2 + C4αρ2,"
L,0.6554433221099888,"where we have used that Uk, Wk ≥0. Letting"
L,0.6565656565656566,"Rk = Vk + αρ k−1
X"
L,0.6576879910213244,"j=1
Uj + α k−1
X"
L,0.6588103254769921,"j=1
Wj,"
L,0.6599326599326599,we then have
L,0.6610549943883277,"Rk+1 ≤(1 + C1α2 + C3αρ2)Rk + C2α2 + C4αρ2,"
L,0.6621773288439955,which implies
L,0.6632996632996633,"Rk+1 ≤(1 + C1α2 + C3αρ2)kR1 + (C2α2 + C4αρ2) k
X"
L,0.6644219977553311,"j=1
(1 + C1α2 + C3αρ2)k−j. Now, k
X"
L,0.6655443322109988,"j=1
(1 + C1α2 + C3αρ2)k−j = k−1
X"
L,0.6666666666666666,"j=0
(1 + C1α2 + C3αρ2)j"
L,0.6677890011223344,= (1 + C1α2 + C3αρ2)k −1
L,0.6689113355780022,(1 + C1α2 + C3αρ2) −1
L,0.67003367003367,= (1 + C1α2 + C3αρ2)k −1
L,0.6711560044893379,C1α2 + C3αρ2
L,0.6722783389450057,≤(1 + C1α2 + C3αρ2)k
L,0.6734006734006734,"C1α2 + C3αρ2
."
L,0.6745230078563412,"Therefore,"
L,0.675645342312009,"Rk+1 ≤(1 + C1α2 + C3αρ2)k

R1 + C2α2 + C4αρ2"
L,0.6767676767676768,"C1α2 + C3αρ2 
."
L,0.6778900112233446,Fix the number of iterations K ≥1. Now
L,0.6790123456790124,"ρ = min

K−1/4, 1"
L,0.6801346801346801,2L
L,0.6812570145903479,"
≤
1
K1/4 ≤1."
L,0.6823793490460157,"Therefore, αρ K
X"
L,0.6835016835016835,"j=1
(Uj + Wj) ≤αρ K
X"
L,0.6846240179573513,"j=1
Uj + α K
X"
L,0.6857463524130191,"j=1
Wj ≤RK+1"
L,0.6868686868686869,"≤(1 + C1α2 + C3αρ2)K

R1 + C2α2 + C4αρ2"
L,0.6879910213243546,"C1α2 + C3αρ2 
."
L,0.6891133557800224,Under review as a conference paper at ICLR 2022
L,0.6902356902356902,"Dividing through by αρK, we obtain"
K,0.691358024691358,"1
K K
X"
K,0.6924803591470258,"j=1
(Uj + Wj) ≤(1 + C1α2 + C3αρ2)K αρK"
K,0.6936026936026936,"
R1 + C2α2 + C4αρ2"
K,0.6947250280583613,C1α2 + C3αρ2
K,0.6958473625140292,"
,
(60)"
K,0.696969696969697,"and since α = Cfρ2, we also have"
K,0.6980920314253648,C2α2 + C4αρ2
K,0.6992143658810326,C1α2 + C3αρ2 = CfC2 + C4
K,0.7003367003367004,"CfC1 + C3
."
K,0.7014590347923682,"Furthermore,"
K,0.7025813692480359,ρ ≤K−1
K,0.7037037037037037,4 =⇒α ≤CfK−1 2 .
K,0.7048260381593715,Substituting these into (60) yields
K,0.7059483726150393,"1
K K
X"
K,0.7070707070707071,"j=1
(Uj + Wj) ≤"
K,0.7081930415263749,"
1 + Cf (Cf C1+C3) K
K αρK"
K,0.7093153759820426,"
R1 + CfC2 + C4"
K,0.7104377104377104,CfC1 + C3 
K,0.7115600448933782,≤exp(Cf(CfC1 + C3)) αρK
K,0.712682379349046,"
R1 + CfC2 + C4"
K,0.7138047138047138,CfC1 + C3
K,0.7149270482603816,"
,
(61)"
K,0.7160493827160493,"where we have used that for any t ≥0, 1 + t/K ≤et/K, so therefore (1 + t/K)K ≤et."
K,0.7171717171717171,"The worst-case rates in terms of K occur when ρ = K−1/4 and α = CfK−1/2. This is the case
when K ≥(2L)4. Substituting these into the denominator yields, for K ≥(2L)4, that"
K,0.7182940516273849,"1
K K
X"
K,0.7194163860830527,"j=1
(Uj + Wj) ≤exp(Cf(CfC1 + C3))"
K,0.7205387205387206,CfK1/4
K,0.7216610549943884,"
R1 + CfC2 + C4"
K,0.7227833894500562,"CfC1 + C3 
."
K,0.7239057239057239,"Thus, since Gk ≤max{τ, τ −1} (Uk + Wk) , we obtain"
K,0.7250280583613917,"1
K K
X"
K,0.7261503928170595,"j=1
E[Gj] ≤max{τ, τ −1} exp (Cf(CfC1 + C3))"
K,0.7272727272727273,CfK1/4
K,0.7283950617283951,"
∥p1 −p∗∥2 + CfC2 + C4"
K,0.7295173961840629,"CfC1 + C3 
,"
K,0.7306397306397306,which is (58).
K,0.7317620650953984,"When K < (2L)4, (57) can similarly be obtained by substituting ρ = (2L)−1 and α = Cf(2L)−2
into (61)."
K,0.7328843995510662,"F
APPROXIMATION RESIDUALS"
K,0.734006734006734,"In this section we derive the approximation residual used to assess the performance of the algorithms
in the numerical experiments. This residual relies on the following product-space reformulation
of (1)."
K,0.7351290684624018,"F.1
PRODUCT-SPACE REFORMULATION AND RESIDUAL PRINCIPLE"
K,0.7362514029180696,"Recall (1), the monotone inclusion we are solving:"
K,0.7373737373737373,"Find z ∈Rd : 0 ∈ n
X"
K,0.7384960718294051,"i=1
Ai(z) + B(z)."
K,0.7396184062850729,"In this section we demonstrate a “product-space"" reformulation of (1) which allows us to rewrite
it in a standard form involving just two operators, one maximal monotone and the other monotone
and Lipschitz. This approach was pioneered in (Briceño-Arias & Combettes, 2011; Combettes &
Pesquet, 2012). Along with allowing for a simple deﬁnition of an approximation residual as a measure
of approximation error in solving (1), it allows one to apply operator splitting methods originally
formulated for two operators to problems such as (1) for any ﬁnite n."
K,0.7407407407407407,Under review as a conference paper at ICLR 2022
K,0.7418630751964085,Observe that solving (1) is equivalent to
K,0.7429854096520763,"Find (w1, . . . , wn, z) ∈R(n+1)d :
wi ∈Ai(z),
i ∈1..n 0 ∈ n
X"
K,0.7441077441077442,"i=1
wi + B(z)."
K,0.745230078563412,"This formulation resembles that of the extended solution set S used in projective spitting, as given
in (5), except that it combines the ﬁnal two conditions in the deﬁnition of S, and thus does not need
the ﬁnal dual variable wn+1. From the deﬁnition of the inverse of an operator, the above formulation
is equivalent to"
K,0.7463524130190797,"Find (w1, . . . , wn, z) ∈R(n+1)d :
0 ∈A−1
i (wi) −z,
i ∈1..n 0 ∈ n
X"
K,0.7474747474747475,"i=1
wi + B(z)."
K,0.7485970819304153,"These conditions are in turn equivalent to ﬁnding (w1, . . . , wn, z) ∈R(n+1)d such that"
K,0.7497194163860831,"0 ∈A (w1, . . . , wn, z) + B(w1, . . . , wn, z),
(62)"
K,0.7508417508417509,where A is the set-valued map
K,0.7519640852974186,"A (w1, . . . , wn, z) 7→A−1
1 (w1) × A−1
2 (w2) × . . . × A−1
n (wn) × {0}
(63)"
K,0.7530864197530864,and B is the single-valued operator
K,0.7542087542087542,"B(w1, . . . , wn, z) 7→  "
K,0.755331088664422,"0
· · ·
0
−I
...
...
...
...
0
· · ·
0
−I
I
· · ·
I
0    "
K,0.7564534231200898,"w1
...
wn
z  +  "
K,0.7575757575757576,"0
...
0
B(z) "
K,0.7586980920314254,".
(64)"
K,0.7598204264870931,"It is easily established that B is maximal monotone and Lipschitz continuous, while A is maximal
monotone. Letting T
.= A + B, it follows from (Bauschke & Combettes, 2017, Proposition
20.23) that T is maximal monotone. Thus, we have reformulated (1) as the monotone inclusion
0 ∈T (q) for q in the product space R(n+1)d. A vector z ∈Rd solves (1) if and only if there exists
(w1, . . . , wn) ∈Rnd such that 0 ∈T (q), where q = (w1, . . . , wn, z)."
K,0.7609427609427609,"For any pair (q, v) such that v ∈T (q), ∥v∥2 represents an approximation residual for q in the sense
that v = 0 implies q is a solution to (62). One may take ∥v∥2 as a measure of the error of q as an
approximate solution to (62), and it can only be 0 if q is a solution. Given two approximate solutions
q1 and q2 with certiﬁcates v1 ∈T(q1) and v2 ∈T (q2), we will treat q1 as a “better” approximate
solution than q2 if ∥v1∥2 < ∥v2∥2. Doing so is somewhat analogous to the practice, common in
optimization, of using the gradient ∥∇f(x)∥2 as a measure of quality of an approximate minimizer
of some differentiable function f. However, note that since T (q1) is a set, there may exist elements
of T (q1) with smaller norm than v1. Thus any given certiﬁcate v1 only corresponds to an upper
bound on dist2(0, T (q1))."
K,0.7620650953984287,"F.2
APPROXIMATION RESIDUAL FOR PROJECTIVE SPLITTING"
K,0.7631874298540965,"In SPS (Algorithm 1), for i ∈1..n, the pairs (xk
i , yk
i ) are chosen so that yk
i ∈Ai(xk
i ). This can be
seen from the deﬁnition of the resolvent. Thus xk
i ∈A−1
i (yk
i ). Observe that vk .=  "
K,0.7643097643097643,"xk
1 −zk
...
xk
n −zk"
K,0.7654320987654321,"B(zk) + Pn
i=1 yk
i "
K,0.7665544332210998,"∈T (yk
1, . . . , yk
n, zk).
(65)"
K,0.7676767676767676,The approximation residual for SPS is thus
K,0.7687991021324355,"Rk .= ∥vk∥2 = n
X"
K,0.7699214365881033,"i=1
∥zk −xk
i ∥2 +
B(zk) + n
X"
K,0.7710437710437711,"i=1
yk
i
2
(66)"
K,0.7721661054994389,Under review as a conference paper at ICLR 2022
K,0.7732884399551067,"which is an approximation residual for (yk
1, . . . , yk
n, zk) in the sense deﬁned above. We may relate
Rk to the approximation residual Gk for SPS from Section 5 as follows: Rk = n
X"
K,0.7744107744107744,"i=1
∥zk −xk
i ∥2 +"
K,0.7755331088664422,"B(zk) + n
X"
K,0.77665544332211,"i=1
yk
i  2 = n
X"
K,0.7777777777777778,"i=1
∥zk −xk
i ∥2 +"
K,0.7789001122334456,"B(zk) + n
X"
K,0.7800224466891134,"i=1
yk
i − n+1
X"
K,0.7811447811447811,"i=1
wk
i  2 ≤ n
X"
K,0.7822671156004489,"i=1
∥zk −xk
i ∥2 + 2∥B(zk) −wk
n+1∥2 + 2  n
X"
K,0.7833894500561167,"i=1
(yk
i −wk
i )  2 ≤ n
X"
K,0.7845117845117845,"i=1
∥zk −xk
i ∥2 + 2∥B(zk) −wk
n+1∥2 + 2n n
X i=1"
K,0.7856341189674523,"yk
i −wk
i
2 ≤2nGk"
K,0.7867564534231201,"where in the second equality we have used the fact that Pn+1
i=1 wk
i = 0. Thus, Rk has the same
convergence rate as Gk given in Theorem 2."
K,0.7878787878787878,"Note that while the certiﬁcate given in (65) focuses on the primal iterate zk, it may be changed to
focus on any xk
i for i = 1, . . . , n, by using"
K,0.7890011223344556,"vk
i
.=  "
K,0.7901234567901234,"xk
1 −xk
i
...
xk
n −xk
i
B(xk
i ) + Pn
i=1 yk
i "
K,0.7912457912457912,"∈T (yk
1, . . . , yk
n, xk
i )."
K,0.792368125701459,"The approximation residual ∥vk
i ∥2 may also be shown to have the same rate as Gk by following
similar derivations to those above for Rk."
K,0.7934904601571269,"F.3
TSENG’S METHOD"
K,0.7946127946127947,"Tseng’s method (Tseng, 2000) can be applied to (62), resulting in the following recursion with iterates
qk, ¯qk ∈R(n+1)d:"
K,0.7957351290684624,"¯qk = JαA (qk −αB(qk))
(67)"
K,0.7968574635241302,"qk+1 = ¯qk + α
 
B(qk) −B(¯qk)

,
(68)"
K,0.797979797979798,"where A and B are deﬁned in (63) and (64). The resolvent of A may be readily computed from the
resolvents of the Ai using Moreau’s identity (Bauschke & Combettes, 2017, Proposition 23.20)."
K,0.7991021324354658,"Analogous to SPS, Tseng’s method has an approximation residual, which in this case is an element of
T (¯qk). In particular, using the general properties of resolvent operators as applied to JαA , we have
1
α(qk −¯qk) −B(qk) ∈A (¯qk)."
K,0.8002244668911336,"Also, rearranging (68) produces
1
α(¯qk −qk+1) + B(qk) = B(¯qk)."
K,0.8013468013468014,"Adding these two relations produces
1
α(qk −qk+1) ∈A (¯qk) + B(¯qk) = T (¯qk)"
K,0.8024691358024691,"Therefore,"
K,0.8035914702581369,"RTseng
k
.= 1"
K,0.8047138047138047,α2 ∥qk −qk+1∥2
K,0.8058361391694725,"represents a measure of the approximation error for Tseng’s method equivalent to Rk deﬁned in (66)
for SPS."
K,0.8069584736251403,Under review as a conference paper at ICLR 2022
K,0.8080808080808081,"F.4
FRB"
K,0.8092031425364759,"The forward-reﬂected-backward method (FRB) (Malitsky & Tam, 2020) is another method that may
be applied to the splitting T = A + B for A and B as deﬁned in (63) and (64). Doing so yields
recursion"
K,0.8103254769921436,"qk+1 = JαA

qk −α
 
2B(qk) −B(qk−1)

."
K,0.8114478114478114,"Following similar arguments to those for Tseng’s method, it can be shown that"
K,0.8125701459034792,"vk
FRB
.= 1"
K,0.813692480359147,"α
 
qk−1 −qk
+ B(qk) + B(qk−2) −2B(qk−1) ∈T (qk)."
K,0.8148148148148148,"Thus, FRB admits the following approximation residual equivalent to Rk for SPS:"
K,0.8159371492704826,"RFRB
k
.= ∥vk
FRB∥2."
K,0.8170594837261503,"Finally, we remark that the stepsizes used in both the Tseng and FRB methods can be chosen via a
linesearch procedure that we do not detail here."
K,0.8181818181818182,"F.5
STOCHASTIC TSENG METHOD"
K,0.819304152637486,"The stochastic version of Tseng’s method of (Böhm et al., 2020) (S-Tseng) may be applied to the
inclusion 0 ∈A (q) + B(q), since the operator A may be written as a subdifferential. However,
unlike the deterministic Tseng method, it does not produce a valid residual. Note also that S-Tseng
outputs an ergodic sequence qk
erg. To construct a residual for the ergodic sequence, we compute a
deterministic step of Tseng’s method according to (67)-(68), starting at qk
erg. That is, letting"
K,0.8204264870931538,"¯qk = JαA (qk
erg −B(qk
erg))"
K,0.8215488215488216,"qk+1 = ¯qk + α(B(qk
erg) −B(¯qk)),
we can then compute essentially the same residual as in Section F.3,"
K,0.8226711560044894,"RS-Tseng
k
.= 1"
K,0.8237934904601572,"α2 ∥qk
erg −qk+1∥2."
K,0.8249158249158249,"To construct the stochastic oracle for S-Tseng, we assumed B(z) = 1"
K,0.8260381593714927,"m
Pm
i=1 Bi(z). Then we used"
K,0.8271604938271605,"˜
B(w1, . . . , wn, z) 7→  "
K,0.8282828282828283,"0
· · ·
0
−I
...
...
...
...
0
· · ·
0
−I
I
· · ·
I
0    "
K,0.8294051627384961,"w1
...
wn
z  +  "
K,0.8305274971941639,"0
...
0
1
|B|
P
j∈B Bj(z) "
K,0.8316498316498316,".
(69)"
K,0.8327721661054994,"for some minibatch B ∈{1, . . . , m}."
K,0.8338945005611672,"F.6
VARIANCE-REDUCED FRB"
K,0.835016835016835,"The FRB-VR method of Alacaoglu et al. (2021) can also be applied to 0 ∈A (q) + B(q), using the
same stochastic oracle ˜
B deﬁned in (69). if we let the iterates of FRB-VR be (qk, pk), then line 4 of
Algorithm 1 of Alacaoglu et al. (2021) can be written as"
K,0.8361391694725028,"ˆqk = qk −τ(B(pk) + ˜
B(qk) −˜
B(pk))
(70)"
K,0.8372615039281706,"qk+1 = JτA (ˆqk).
(71)"
K,0.8383838383838383,"Once again, the method does not directly produce a residual, but one can be developed from the
algorithm deﬁnition as follows: (71) yields τ −1(ˆqk −qk+1) ∈A (qk+1) and hence"
K,0.8395061728395061,"τ −1(ˆqk −qk+1) + B(qk+1) ∈(A + B)(qk+1).
Therefore we use the residual
RFRB-VR
k
= ∥τ −1(ˆqk −qk+1) + B(qk+1)∥2."
K,0.8406285072951739,"Figure 1 plots Rk for SPS, RTseng
k
for Tseng’s method, RFRB
k
for FRB, RS-Tseng
k
for S-Tseng, and
RFRB-VR
k
for FRB-VR."
K,0.8417508417508418,Under review as a conference paper at ICLR 2022
K,0.8428731762065096,"F.7
BENEFITS AND DRAWBACKS OF THE PRODUCT SPACE REFORMULATION"
K,0.8439955106621774,"The main beneﬁt of the product space reformulation (PSR) is that it allows one to use familiar
2-operator splitting schemes for solving 0 ∈A (q) + B(q) to solve the more complicated recursion
(1). However, one drawback of this approach is that the operator B, deﬁned in (64), combines a
skew-symmetric consensus matrix with the Lipschitz operator B. Treating B as a single operator
necessitates using a single stepsize for both of its constituent operators, but the B component will
generally have a much larger Lipschitz constant than the skew part, necessitating a smaller stepsize
than is ideal for the skew operator. This difﬁculty can be countered by using different stepsizes
for the primal and dual components, but that strategy introduces additional tuning parameters. In
other works, methods based on PSR have exhibited slower convergence than deterministic projective
splitting methods (Johnstone & Eckstein, 2021; 2020b). However, in our experiments in Section 7,
the performance is comparable."
K,0.8451178451178452,"G
VARIATIONAL INEQUALITIES"
K,0.8462401795735129,"For a mapping B : Rd →Rd and a closed and convex set C, the variational inequality problem
(Harker & Pang, 1990) is to ﬁnd z∗∈C such that
B(z∗)⊤(z −z∗) ≥0, ∀z ∈C.
(72)
Consider the normal cone mapping discussed in Section 2 and deﬁned as
NC(x) .= {g : g⊤(y −x) ≤0 ∀y ∈C}
It is easily seen that (72) is equivalent to ﬁnding z∗such that −B(z∗) ∈NC(z∗). Hence, if B is
monotone, (72) is equivalent to the monotone inclusion
0 ∈B(z∗) + NC(z∗).
(73)
Thus, monotone variational inequalities are a special case of monotone inclusions with two operators,
one of which is single-valued and the other is the normal cone map of the constraint set C. As a
consequence, methods for monotone inclusions can be used to solve monotone variational inequality
problems. The reverse, however, may not be true. For example, the analysis of the extragradient
method (Korpelevich, 1977) relies on the second operator NC in (73) being a normal cone, as opposed
to a more general monotone operator. We are not aware of any direct extension of the extragradient
method’s analysis allowing a more general resolvent to be used in place of the projection map
corresponding to NC."
K,0.8473625140291807,"The Restricted Gap Function
There is a disadvantage to pursuing convergence rates based on
variational inequalities (as in Böhm et al. (2020) and Alacaoglu et al. (2021)) rather than monotone
inclusions. Convergence rate analyses for variational inequalities focus on the gap function:
GC(z) .= sup
z′∈C
B(z′)⊤(z −z′).
(74)"
K,0.8484848484848485,"It can be shown that GC(z) ≥0 and GC(z) = 0 if and only if z solves (72). However, (74) is
meaningless for most problems, since unless C is compact, GC(z) is typically equal to +∞for any
nonsolution (Diakonikolas, 2020). Thus researchers instead focus on the restricted gap function
(Nesterov, 2007)
GC2(z) .= sup
z′∈C2
B(z′)⊤(z −z′).
(75)"
K,0.8496071829405163,"where C2 is an arbitrary compact set. However, now the results are only meaningful over the set C2.
Thus, C2 must be chosen large enough so that the iterates of the algorithm remain in the interior of
C2 (Böhm et al., 2020). Further, the convergence rate bound depends on the diameter of C2. For
some algorithms (Mokhtari et al., 2020) a valid set is provided which bounds the iterates. However
Böhm et al. (2020) and Alacaoglu et al. (2021) do not provide one, although in principle it could be
done so long as the ergodic sequence can be bounded almost-surely. Thus, the convergence rates
depending on (75) in Böhm et al. (2020) and Alacaoglu et al. (2021) are somewhat incomplete in that
they depend on unknown constants."
K,0.8507295173961841,"In contrast, rates based on the approximation residual in the monotone inclusion setting, including
ours given in (57)–(58), completely avoid this pitfall. There is no need to select a compact set
containing the algorithm’s iterates and the constants in our rates are all explicit or depend on standard
quantities such as the initial distance to a solution."
K,0.8518518518518519,Under review as a conference paper at ICLR 2022
K,0.8529741863075196,"H
MEMORY-SAVING TECHNIQUE FOR SPS"
K,0.8540965207631874,"The variables tk
i , xk
i , and yk
i on lines 3-5 of SPS are stored in variables t, x and y. Another two
variables ¯x and ¯y keep track of Pn
i=1 xk
i and Pn
i=1 yk
i . The dual variables are stored as wi for
i ∈1..n and the primal variable as z. Once x = xk
i is computed, the ith dual variable wi can be
partially updated as wi ←wi −αkx. Once all the operators have been processed, the update for each
dual variable may be completed via wi ←wi + αk(n + 1)−1¯x. Also, the primal update is computed
as z ←z −αk¯y. During the calculation loop for the xk
i , yk
i , the terms in approximation residual Rk
may also be accumulated one by one. The total total number of vector elements that must be stored is
(n + 7)d."
K,0.8552188552188552,"I
ADDITIONAL INFORMATION ABOUT THE NUMERICAL EXPERIMENTS"
K,0.856341189674523,We solve the following convex-concave min-max problem:
K,0.8574635241301908,"min
β∈Rd
λ∈R"
K,0.8585858585858586,"max
γ∈Rm ("
K,0.8597081930415263,"λ(δ −κ) + 1 m m
X"
K,0.8608305274971941,"i=1
Ψ(⟨ˆxi, β⟩) + 1 m m
X"
K,0.8619528619528619,"i=1
γi(ˆyi⟨ˆxi, β⟩−λκ) + c∥β∥1 )"
K,0.8630751964085297,"s.t.
∥β∥2 ≤λ/(LΨ + 1)
∥γ∥∞≤1. (76)"
K,0.8641975308641975,"This model is identical to that of (Yu et al., 2021, Thm. 4.3) except for the addition of the ℓ1
regularization term c∥β∥1, where c ≥0 is a given constant. The goal is to learn the model weights β
from a training dataset of m feature vectors ˆxi and corresponding labels ˆyi. Rather than computing
the expected loss over the training set, the formulation uses, for each β, the worst possible distribution
within a Wasserstein-metric ball around the empirical distribution of the {(ˆxi, ˆyi)}, with the parameter
δ ≥0 giving the diameter of the ball and the parameter κ ≥0 specifying the relative weighting of
features and labels. The variables γ and λ parameterize the selection of this worst-case distribution in
response to the model weights β. Finally, Ψ is the logistic loss kernel t 7→log(et + e−t) and LΨ = 1
is the corresponding Lipschitz constant. In all the experiments, we set δ = κ = 1 and c = 10−3."
K,0.8653198653198653,"We now show how we converted this problem to the form (1) for our experiments. Let z be a
shorthand for (λ, β, γ), and deﬁne"
K,0.8664421997755332,"L(z) .= λ(δ −κ) + 1 m m
X"
K,0.867564534231201,"i=1
Ψ(⟨ˆxi, β⟩) + 1 m m
X"
K,0.8686868686868687,"i=1
γi(ˆyi⟨ˆxi, β⟩−λκ)."
K,0.8698092031425365,"The ﬁrst-order necessary and sufﬁcient conditions for the convex-concave saddlepoint problem in
(76) are"
K,0.8709315375982043,"0 ∈B(z) + A1(z) + A2(z)
(77)"
K,0.8720538720538721,where the vector ﬁeld B(z) is deﬁned as
K,0.8731762065095399,B(z) .=
K,0.8742985409652076,"""
∇λ,βL(z)"
K,0.8754208754208754,−∇γL(z) #
K,0.8765432098765432,",
(78) with"
K,0.877665544332211,"∇λ,βL(z) ="
K,0.8787878787878788,"""
δ −κ(1 + 1"
K,0.8799102132435466,"m
Pm
i=1 γi)"
"M
PM",0.8810325476992144,"1
m
Pm
i=1 Ψ′(⟨ˆxi, β⟩)ˆxi + 1"
"M
PM",0.8821548821548821,"m
Pm
i=1 γiˆyiˆxi # and"
"M
PM",0.8832772166105499,∇γL(z) =  
"M
PM",0.8843995510662177,"1
m(ˆy1⟨ˆx1, β⟩−λκ)
..."
"M
PM",0.8855218855218855,"1
m(ˆym⟨ˆxm, β⟩−λκ)  ."
"M
PM",0.8866442199775533,"It is readily conﬁrmed that B deﬁned in this manner is Lipschitz. The monotonicity of B follows
from its being the generalized gradient of a convex-concave saddle function (Rockafellar, 1970)."
"M
PM",0.8877665544332211,Under review as a conference paper at ICLR 2022
"M
PM",0.8888888888888888,"For the set-valued operators, A1(z) corresponds to the constraints and A2(z) to the nonsmooth ℓ1
regularizer, and are deﬁned as"
"M
PM",0.8900112233445566,"A1(z) .= NC1(λ, β) × NC2(γ), where"
"M
PM",0.8911335578002245,"C1 .=

(λ, β) : ∥β∥2 ≤λ/(LΨ + 1)
	
and
C2 .= {γ : ∥γ∥∞≤1}, and"
"M
PM",0.8922558922558923,A2(z) .= {01×1} × c∂∥β∥1 × {0m×1}.
"M
PM",0.8933782267115601,"Here, the notation 0p×1 denotes the p-dimensional vector of all zeros. C1 is a scaled version of
the second-order cone, well known to be a closed convex set, while C2 is the unit ball of the ℓ∞
norm, also closed and convex. Since A1 is a normal cone map of a closed convex set and A2 is the
subgradient map of a closed proper convex function (the scaled 1-norm), both of these operators are
maximal monotone and problem (77) is a special case of (1) for n = 2."
"M
PM",0.8945005611672279,"Stochastic oracle implementation
The operator B : Rm+d+1 7→Rm+d+1, deﬁned in (78), can
be written as"
"M
PM",0.8956228956228957,"B(z) = 1 m m
X"
"M
PM",0.8967452300785634,"i=1
Bi(z) where"
"M
PM",0.8978675645342312,Bi(z) .= 
"M
PM",0.898989898989899,
"M
PM",0.9001122334455668,δ −κ(1 + γi)
"M
PM",0.9012345679012346,"Ψ′(⟨ˆxi, β⟩)ˆxi + γiˆyiˆxi
0(i−1)×1
−(ˆyi⟨ˆxi, β⟩−λκ)"
"M
PM",0.9023569023569024,0(m−i)×1 
"M
PM",0.9034792368125701, .
"M
PM",0.9046015712682379,"In our SPS experiments, the stochastic oracle for B is simply ˜B(z) =
1
|B|
P
i∈B Bi(z) for some
minibatch B ⊆{1, . . . , m}. We used a batchsize of 100."
"M
PM",0.9057239057239057,"Resolvent computations
The resolvent of A1 is readily constructed from the projection maps of
the simple sets C1 and C2, while the resolvent A2 involves the proximal operator of the ℓ1 norm.
Speciﬁcally,"
"M
PM",0.9068462401795735,JρA1(z) =
"M
PM",0.9079685746352413,"""
projC1(λ, β)"
"M
PM",0.9090909090909091,projC2(γ) #
"M
PM",0.9102132435465768,"and
JρA2(z) =  "
"M
PM",0.9113355780022446,"01×1
proxρc∥·∥1(β) 0m×1  ."
"M
PM",0.9124579124579124,"The constraint C1 is a scaled second-order cone and C2 is the ℓ∞ball, both of which have closed-form
projections. The proximal operator of the ℓ1 norm is the well-known soft-thresholding operator
(Parikh & Boyd, 2013, Section 6.5.2). Therefore all resolvents in the formulation may be computed
quickly and accurately."
"M
PM",0.9135802469135802,"SPS stepsize choices
For the stepsize in SPS, we ordinarily require ρk ≤ρ < 1/L for the global
Lipschitz constant L of B. However, since the global Lipschitz constant may be pessimistic, better
performance can often be achieved by experimenting with larger stepsizes. If divergence is observed,
then the stepsize can be decreased. This type of strategy is common for SGD and similar stochastic
methods. Thus, for SPS-decay we set αk = Cdk−0.51 and ρk = Cdk−0.25, and performed a grid
search to select the best Cd from {0.1, 0.5, 1, 5, 10}, arriving at Cd = 1 for epsilon and SUSY, and
Cd = 0.5 for real-sim. For SPS-ﬁxed we used ρ = K−1/4 and α = Cfρ2, and performed a grid
search to select Cf over {0.1, 0.5, 1, 5, 10}, arriving at Cf = 1 for epsilon and real-sim, and Cf = 5
for SUSY. The total number of iterations for SPS-ﬁxed was chosen as follows: For the epsilon dataset,
we used K = 5000, for SUSY we used K = 200, and for real-sim we used K = 1000."
"M
PM",0.9147025813692481,Under review as a conference paper at ICLR 2022
"M
PM",0.9158249158249159,"Figure 2: Approximation residual versus epoch for three LIBSVM benchmark datasets. Left: epsilon,
middle: SUSY, right: real-sim."
"M
PM",0.9169472502805837,"Parameter choices for the other algorithms
All methods are initialized at the same random point.
For Tseng’s method, we used the backtracking linesearch variant with an initial stepsize of 1, θ = 0.8,
and a stepsize reduction factor of 0.7. For FRB, we used the backtracking linesearch variant with the
same settings as for Tseng’s method. For deterministic PS, we used a ﬁxed stepsize of 0.9/L. For
the stochastic Tseng’s method of Böhm et al. (2020), the stepsize αk must satisfy: P∞
k=1 αk = ∞
and P∞
k=1 α2
k < ∞. So we set αk = Ck−d and perform a grid search over {C, d} in the range
[10−4, 10] × [0.51, 1], checking 5 × 5 values to ﬁnd the best setting for each of the three problems.
The selected values are in Table 1."
"M
PM",0.9180695847362514,"epsilon
SUSY
real-sim"
"M
PM",0.9191919191919192,"C
0.56
0.56
0.77"
"M
PM",0.920314253647587,"d
0.6
0.6
0.55"
"M
PM",0.9214365881032548,Table 1: Parameter Values for S-Tseng
"M
PM",0.9225589225589226,"The work of Böhm et al. (2020) also introduced FBFp, a stochastic version of Tseng’s method that
reuses a previously-computed gradient and therefore only needs one additional gradient calculation
per iteration. In our experiments, the performance of the two methods was about the same, so we
only report the performance of stoch. Tseng’s method."
"M
PM",0.9236812570145904,"For variance-reduced FRB, the main parameter is the probability p. We hand-tuned p,arriving at
p = 0.01 for all problems. We set the stepsize to its maximum allowed value of"
"M
PM",0.9248035914702581,τ = 1 −√1 −p
L,0.9259259259259259,"2L
."
L,0.9270482603815937,"Plots versus Epoch
Figure 2 plots the performance of each method versus epoch (i.e. data pass).
This shows an even more dramatic beneﬁt for the stochastic methods than the plots versus time,
since at each iteration the stochastic methods only need to process small amounts of data, whereas
deterministic methods must process all of it. We believe these beneﬁts do not fully manifest
themselves in the plots versus time due to overheads in each iteration of the stochastic methods,
multithreading providing a boost for the deterministic methods, memory access patterns, and other
practical considerations."
L,0.9281705948372615,"Fraction of Nonzero Entries versus Running time
Figure 3 plots the fraction of nonzero entries
in the iterates of each method versus running time. For each method, we used output of proxc∥·∥1.
We observe that our methods produce sparse intermediate iterates for two of the three problems. This
is one of the beneﬁts of proximal splitting algorithms in general, including our method. For the other
problem, SUSY, no method produces sparse iterates, suggesting that c should be increased if sparse
solutions are desired."
L,0.9292929292929293,Under review as a conference paper at ICLR 2022
L,0.9304152637485971,"Figure 3: Fraction of nonzero entries versus running time for the three datasets. Left: epsilon, middle:
SUSY, right: real-sim."
L,0.9315375982042648,"J
LOCAL CONVERGENCE ON NON-MONOTONE PROBLEMS"
L,0.9326599326599326,"The work by Hsieh et al. (2020) provides a local convergence analysis for DSEG applied to locally
monotone problems. Recall that DSEG is equivalent to the special case of SPS for which n = 0.
While extending this result to the more general setting of SPS is beyond the scope of this manuscript,
we next provide a preliminary sketch of how the analysis of Hsieh et al. (2020) might be generalized
to our setting. We leave a formal proof to future work."
L,0.9337822671156004,"Sketch of assumptions and main result
The ﬁrst assumption needed is the existence of an isolated
solution p∗= (z∗, w∗
1, . . . , w∗
n+1) ∈S. We then require that there exists a ball Br(z∗), centered at
z∗, throughout which the operator B is “well-behaved”, meaning that it satisﬁes monotonicity and
Lipschitz continuity. In addition, we need each Ai, for i ∈1..n, to be maximal monotone within this
ball. Outside of the ball, the operators do not need to be monotone or Lipschitz."
L,0.9349046015712682,"Following (Hsieh et al., 2020, Assumption 2′), the noise variance assumptions are slightly stronger
than in the monotone case. In particular, we require that E[∥ϵk∥q|Fk] ≤N q and E[∥ek∥q|Fk] ≤N q
for some q > 2. As before, the noise must be zero-mean. Finally, the stepsize requirements are also
slightly stronger than (12), having the added assumption that P∞
k=1 ρq
k < ∞."
L,0.936026936026936,"With these assumptions, the goal is to show that, so long as the initial point p1 is sufﬁciently close to
p∗, then with high probability pk converges to p∗."
L,0.9371492704826038,"Proof strategy
The initial strategy is to develop the following recursion, satisﬁed by SPS, that does
not (yet) utilize local monotonicity or Lipschitz continuity:"
L,0.9382716049382716,"∥pk+1 −p∗∥2 ≤(1 + c1α2
k)∥pk −p∗∥2 −c2αkρk(T ′
k + lk + rk) −c3αk(r′
k + qk)"
L,0.9393939393939394,"+ c1α2
k
 
∥ek∥2 + ∥ϵk∥2 + c4

+ c5αkq′
k
(79)"
L,0.9405162738496072,"for appropriate constants c1 . . . c5 ≥0. In this inequality, we use"
L,0.941638608305275,"T ′
k
.= τ ρ n
X"
L,0.9427609427609428,"i=1
∥yk
i −wk
i ∥2 + 1 ρτ n
X"
L,0.9438832772166106,"i=1
∥zk −xk
i ∥2, lk .= n
X"
L,0.9450056116722784,"i=1
⟨z∗−xk
i , w∗
i −yk
i ⟩+

z∗−xk
n+1, w∗
i −B(xk
n+1)

,"
L,0.9461279461279462,"rk .= ⟨ϵk, B(˜xk) −wk
n+1⟩,"
L,0.9472502805836139,"r′
k
.= ⟨zk −z∗, ek⟩,"
L,0.9483726150392817,"qk .= (ρ−1
k
−d/2)∥˜xk −zk∥2 −∥˜xk −zk∥∥B(˜xk) −B(zk)∥"
L,0.9494949494949495,"q′
k
.= ρk∥ϵk∥∥Bxk
n+1 −B˜xk∥+ 1"
L,0.9506172839506173,"2d∥B˜xk
n+1 −Bxk
n+1∥2, where"
L,0.9517396184062851,"˜xk .= zk −ρk
 
B(zk) −wk
n+1

d .= 1 −ρL"
L,0.9528619528619529,"1 + ρ/2,
(80)"
L,0.9539842873176206,Under review as a conference paper at ICLR 2022
L,0.9551066217732884,"with L being the local Lipschitz constant of B on Br(z∗). The iterate ˜xk is the analog of the iterate
˜Xt+1/2 used in Hsieh et al. (2020)."
L,0.9562289562289562,"The recursion (79) is derived by once again starting from (13) and following the arguments leading to
(35), but this time not taking conditional expectations. In particular, the upper bounds on ∥∇zϕk∥2"
L,0.957351290684624,"and ∥∇wiϕk∥2 contribute the terms c1α2
k
 
∥ek∥2 + ∥ϵk∥2 + c4) and c1α2
k∥pk −p∗∥2. For i ∈1..n,
the “ϕi,k-gap"" term, ϕi,k(pk) −ϕi,k(p∗), is dealt with in a similar manner to Section C.5, but this
time not using monotonicity as in (36). This contributes T ′
k and the ﬁrst term in lk. Finally, as we
sketch below, the “ϕn+1,k-gap"" term contributes rk, r′
k, qk, q′
k, and the last term in lk."
L,0.9584736251402918,"For the “ϕn+1,k-gap”, that is, ϕn+1,k(pk) −ϕn+1,k(p∗), we have to depart from the analysis in
Section C.6 and use an alternative argument involving ˜xk. We now provide some details of this
argument: in the following, we use Bz as shorthand for B(z) for any vector z ∈Rd. We begin the
analysis with"
L,0.9595959595959596,"ϕn+1,k(pk) = ⟨zk −xk
n+1, yk
n+1 −wk
n+1⟩"
L,0.9607182940516273,"= ⟨zk −xk
n+1, Bxk
n+1 −wk
n+1⟩+ ⟨zk −xk
n+1, ek⟩
|
{z
}
part of r′
k"
L,0.9618406285072951,".
(81)"
L,0.9629629629629629,"The ﬁnal term will combine with the term ⟨xk
n+1 −z∗, ek⟩coming from"
L,0.9640852974186308,"−ϕn+1,k(p∗) = ⟨z∗−xk
n+1, w∗
n+1 −yk
n+1⟩"
L,0.9652076318742986,"= ⟨z∗−xk
n+1, w∗
n+1 −Bxk
n+1⟩+ ⟨xk
n+1 −z∗, ek
n+1⟩
(82)"
L,0.9663299663299664,"to yield r′
k above. Equation (82) also yields the second term in lk. Using that ˜xk −xk
n+1 = ρkϵk, we
rewrite the ﬁrst term in (81) as"
L,0.9674523007856342,"⟨zk −xk
n+1, Bxk
n+1 −wk
n+1⟩= ⟨zk −˜xk, Bxk
n+1 −wk
n+1⟩+ ⟨˜xk −xk
n+1, Bxk
n+1 −wk
n+1⟩"
L,0.9685746352413019,"= ⟨zk −˜xk, Bxk
n+1 −wk
n+1⟩+ ρk⟨ϵk, Bxk
n+1 −wk
n+1⟩"
L,0.9696969696969697,"= ⟨zk −˜xk, Bxk
n+1 −wk
n+1⟩+ ρk⟨ϵk, Bxk
n+1 −B˜xk⟩
(83)"
L,0.9708193041526375,"+ ρk ⟨ϵk, B˜xk −wk
n+1⟩
|
{z
}
rk ."
L,0.9719416386083053,"Next, the terms in (83) admit the lower bound"
L,0.9730639730639731,"⟨zk −˜xk, Bxk
n+1 −wk
n+1⟩+ ρk⟨ϵk, Bxk
n+1 −B˜xk⟩"
L,0.9741863075196409,"≥⟨zk −˜xk, Bxk
n+1 −wk
n+1⟩−ρk∥ϵk∥∥Bxk
n+1 −B˜xk∥
|
{z
}
ﬁrst part of q′
k ."
L,0.9753086419753086,"Considering the ﬁrst term on right-hand side of this bound, we also have"
L,0.9764309764309764,"⟨zk −˜xk, Bxk
n+1 −wk
n+1⟩= ⟨zk −˜xk, B˜xk −wk
n+1⟩+ ⟨zk −˜xk, Bxk
n+1 −B˜xk⟩"
L,0.9775533108866442,"≥⟨zk −˜xk, B˜xk −wk
n+1⟩−d"
L,0.978675645342312,2∥zk −˜xk∥2 −1
L,0.9797979797979798,"2d∥B˜xk −Bxk
n+1∥2"
L,0.9809203142536476,"|
{z
}
second part of q′
k"
L,0.9820426487093153,"for any d > 0, using Young’s inequality. Finally, for the ﬁrst two terms of the right-hand side of the
above relation, we may write"
L,0.9831649831649831,"⟨zk −˜xk, B˜xk −wk
n+1⟩−d"
L,0.9842873176206509,2∥zk −˜xk∥2
L,0.9854096520763187,"= ⟨zk −˜xk, Bzk −wk
n+1⟩+ ⟨zk −˜xk, B˜xk −Bzk⟩−d"
L,0.9865319865319865,2∥zk −˜xk∥2
L,0.9876543209876543,"≥(ρ−1
k
−d/2)∥zk −˜xk∥2 −∥zk −˜xk∥∥B˜xk −Bzk∥
|
{z
}
qk ,"
L,0.9887766554433222,Under review as a conference paper at ICLR 2022
L,0.98989898989899,"where in the ﬁnal inequality we use the Cauchy-Schwartz inequality and substitute Bzk −wk
n+1 =
ρ−1
k (zk −˜xk), from the deﬁnition of ˜xk in (80). We have now accounted for all the terms appearing
in (79)."
L,0.9910213243546577,"The recursion (79) is analogous to equation (F.7) on page 24 of Hsieh et al. (2020) and provides
the starting point for the local convergence analysis. The next step would be to derive an analog of
Theorem F.1. of Hsieh et al. (2020) using (79). The following translation to the notation of Theorem
F.1. could be used (note that Hsieh et al. (2020) uses t for iteration counter):"
L,0.9921436588103255,"Dk = ∥pk −p∗∥2,"
L,0.9932659932659933,"ζk = c2αkρk(T ′
k + lk) + c3αkqk,"
L,0.9943883277216611,"ξk = −c2αkρkrk −c3αkr′
k,"
L,0.9955106621773289,"χk = c1α2
k
 
∥ek∥2 + ∥ϵk∥2 + ∥pk −p∗∥2 + c4

+ c5αkq′
k,"
L,0.9966329966329966,"and the event Eρ
∞is translated to"
L,0.9977553310886644,"Eρ
∞=

xk
n+1 ∈Br(z∗), ˜xk ∈Bρr(z∗), pk ∈Bρr(p∗) for all k = 1, 2, . . .
	
."
L,0.9988776655443322,An analog of Theorem 2 of Hsieh et al. (2020) could then be developed based on this result.
